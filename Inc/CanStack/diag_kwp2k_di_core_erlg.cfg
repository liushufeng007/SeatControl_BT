#ifndef DIAG_KWP2K_DI_CORE_ERLG_CFG
#define DIAG_KWP2K_DI_CORE_ERLG_CFG

/***************************************************************************
                I N C L U D E   F I L E S
***************************************************************************/
#ifndef KERNEL_PRIVATE_DIAG
#define KERNEL_PRIVATE_DIAG
#endif
#include "string.h"
#include "diag_kwp2k_di_core_mgr.h"
#include "fdiag.h"
#include "il_par.h"

#ifdef  KERNEL_PRIVATE_DIAG
   /*---------------------------------------------------------------
     Include files FOR KERNEL_PRIVATE_DIAG configuration items go here.
   ---------------------------------------------------------------*/
#endif

#ifdef  KERNEL_RESTRICTED_DIAG
   /*---------------------------------------------------------------
      Include files for KERNEL_RESTRICTED_DIAG configuration items go here.
   ---------------------------------------------------------------*/
#endif


/*---------------------------------------------------------------
   Include files for GLOBAL configuration items go here.
---------------------------------------------------------------*/


/***************************************************************************
   P U B L I C   M A C R O   A N D   T Y P E   D E F I N I T I O N S
***************************************************************************/

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DTC_TABLE                                       */
/*               PROD_SPEC_NUMBER_OF_DTCS                                  */
/*                                                                         */
/* TYPE:         MACROS                                                    */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of product specific 16-bit */
/*               diagnostic trouble codes (DTC's).  DTC's are logged in    */
/*               real-time as they occur using the "KernelLogcon2Error"    */
/*               service (desription and prototype in con2erlg.h).  The    */
/*               first parameter specifies the DTC that is being logged as */
/*               an INDEX into the PROD_SPEC_DTC_TABLE.  By convention, a  */
/*               symbolic INDEX name is used (the symbolic name is the     */
/*               name of the DTC as represented in the                     */
/*               PROD_SPEC_DTC_TABLE with a prefix of "ERC_").  For        */
/*               example, to log an "ANTENNA_NOT_CONNECTED" DTC, the       */
/*               following call is used:                                   */
/*                                                                         */
/*               KernelLogcon2Error(ERC_ANTENNA_NOT_CONNECTED, status);    */
/*               status - a byte contains the ignition counter value       */
/*               during which the DTC is logged.                           */
/*                                                                         */
/*               The first DTC in PROD_SPEC_DTC_TABLE has an index of 1,   */
/*               not 0 (0 is an invalid index), and indexes increase by 1. */
/*                                                                         */
/*               The PROD_SPEC_NUMBER_OF_DTCS must equate to the number    */
/*               of DTCS which are in the DTC table.                       */
/*                                                                         */
/*                                                                         */
/* REQUIRED:     YES (however, the list can be NULL)                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG - PROD_SPEC_DTC_TABLE                 */
/*                                                                         */
/*-------------------------------------------------------------------------*/

/*
__DTC_GROUP_CONFIGURATION(){ }
*/

/*
* If no or only one group supported leave other *
* group un-configured 							*
*/
#define GROUP1_OF_DTCS          0x00FFFFFFul
#define GROUP2_OF_DTCS          GROUP1_OF_DTCS
#define GROUP3_OF_DTCS          GROUP1_OF_DTCS

/*
__DTC_GROUP_CONFIGURATION_SERVICE_17(){ }
*/

/*
* If no or only one group supported leave other *
* group un-configured 							*
*/

#define GROUP1_OF_DTCS_17          0x0000FF00ul
#define GROUP2_OF_DTCS_17          0x00000000ul
#define GROUP3_OF_DTCS_17          0x00000000ul

/*
__DTC_GROUP_CONFIGURATION_SERVICE_18(){ }
*/

/*
* If no or only one group supported leave other *
* group un-configured 							*
*/

#define GROUP1_OF_DTCS_18          0x0000FF00ul
#define GROUP2_OF_DTCS_18          0x00000000ul
#define GROUP3_OF_DTCS_18          0x00000000ul

/*
__FDC_Configuration(){ }
*/
#define YES 0x01 /* Supported */
#define NO  0x00 /* Not Supported */

/*
__DTC_STATUS_ALGORITHM_CONFIGURATION(){ }
*/

/* ISO_14229_BASED = 0x01 or KWP_BASED = 0x02 */
#define DTC_STATUS_ALGORITHM ISO_14229_BASED

#if (DTC_STATUS_ALGORITHM == ISO_14229_BASED)
/* Configure FDC is supported or not */
#define FDC_ENABLED NO

/* Configure whether FDC max value should be used to set Bit0(Test Failed)
   If FDC max value should set Test failed then define the macro as YES or else NO.
   FDC_CONFIG_TEST_FAILED = YES -> Upon reaching FDC max, Bit0(TestFailed) and Bit3(Confirmed DTC) will set.
   FDC_CONFIG_TEST_FAILED = NO -> When FDC>0, Bit 0 will get set and when FDC=MAX, Bit 3 will set.
   Note: For GGDS based program configure this macro as YES.
   If this is configured as No */
#if (FDC_ENABLED == YES)
#define FDC_CONFIG_TEST_FAILED NO
#endif /* (FDC_ENABLED == YES) */
#endif

/*
__DTC_PRODUCT_SPECIFIC_CONFIGURATION(){ }
*/

#if(SCM_SEATCONTROL_VARIANT == SCM_R_VARIANT)
/*---------------------------------------------------------------------------*/
/* DEFINE PRODUCT SPECIFIC DTC'S HERE IN THE DTC TABLE.                      */
/*---------------------------------------------------------------------------*/

/*first DTC table*/
#define DTC_BAT_VOL_HIGH            ((UINT32)0x970017)
#define DTC_BAT_VOL_LOW             ((UINT32)0x970016)
#define DTC_CAN_BUS_OFF             ((UINT32)0xF80088)
#define DTC_EASY_IN_SW_STUCK        ((UINT32)0x970200)
#define DTC_EASY_OUT_SW_STUCK       ((UINT32)0x970300)
#define DTC_SEAT_FORWARD_SW_STUCK   ((UINT32)0x970400)
#define DTC_SEAT_BACKWARD_SW_STUCK  ((UINT32)0x970500)
#define DTC_BACK_FORWARD_SW_STUCK   ((UINT32)0x970600)
#define DTC_BACK_BACKWARD_SW_STUCK  ((UINT32)0x970700)
#define DTC_SEAT_HALL_SHORT_GND     ((UINT32)0x970900)
#define DTC_SEAT_HALL_SHORT_BAT     ((UINT32)0x970912)
#define DTC_BACK_HALL_SHORT_GND     ((UINT32)0x970B00)
#define DTC_BACK_HALL_SHORT_BAT     ((UINT32)0x970B12)
#define DTC_VCU_MESSAGE_LOST        ((UINT32)0xF81287)
#define DTC_BCM_MESSAGE_LOST        ((UINT32)0xF81087)
#define DTC_ABM_MESSAGE_LOST        ((UINT32)0xF81387)

#define PROD_SPEC_DTC_TABLE \
	DTC_BAT_VOL_HIGH,\
    DTC_BAT_VOL_LOW,\
    DTC_CAN_BUS_OFF,\
    DTC_EASY_IN_SW_STUCK,\
    DTC_EASY_OUT_SW_STUCK,\
    DTC_SEAT_FORWARD_SW_STUCK,\
    DTC_SEAT_BACKWARD_SW_STUCK,\
    DTC_BACK_FORWARD_SW_STUCK,\
    DTC_BACK_BACKWARD_SW_STUCK,\
    DTC_SEAT_HALL_SHORT_GND,\
    DTC_SEAT_HALL_SHORT_BAT,\
    DTC_BACK_HALL_SHORT_GND,\
    DTC_BACK_HALL_SHORT_BAT,\
    DTC_VCU_MESSAGE_LOST,\
    DTC_BCM_MESSAGE_LOST,\
    DTC_ABM_MESSAGE_LOST



/*---------------------------------------------------------------------------*/
/* DEFINE SYMBOLIC NAMES FOR DTC'S HERE.                                     */
/*---------------------------------------------------------------------------*/
#define DTC_ERC_BAT_VOL_HIGH             1
#define DTC_ERC_BAT_VOL_LOW              2
#define DTC_ERC_CAN_BUS_OFF              3
#define DTC_ERC_EASY_IN_SW_STUCK         4
#define DTC_ERC_EASY_OUT_SW_STUCK        5
#define DTC_ERC_SEAT_FORWARD_SW_STUCK    6
#define DTC_ERC_SEAT_BACKWARD_SW_STUCK   7
#define DTC_ERC_BACK_FORWARD_SW_STUCK    8
#define DTC_ERC_BACK_BACKWARD_SW_STUCK   9
#define DTC_ERC_SEAT_HALL_SHORT_GND      10
#define DTC_ERC_SEAT_HALL_SHORT_BAT      11
#define DTC_ERC_BACK_HALL_SHORT_GND      12
#define DTC_ERC_BACK_HALL_SHORT_BAT      13
#define DTC_ERC_VCU_MESSAGE_LOST         14
#define DTC_ERC_BCM_MESSAGE_LOST         15
#define DTC_ERC_ABM_MESSAGE_LOST         16

#else  /* else of #if(SCM_SEATCONTROL_VARIANT == SCM_R_VARIANT) */

/*---------------------------------------------------------------------------*/
/* DEFINE PRODUCT SPECIFIC DTC'S HERE IN THE DTC TABLE.                      */
/*---------------------------------------------------------------------------*/

/*first DTC table*/
#define DTC_BAT_VOL_HIGH            ((UINT32)0x970017)
#define DTC_BAT_VOL_LOW             ((UINT32)0x970016)
#define DTC_CAN_BUS_OFF             ((UINT32)0xF80088)
#define DTC_SEAT_FORWARD_SW_STUCK   ((UINT32)0x970400)
#define DTC_SEAT_BACKWARD_SW_STUCK  ((UINT32)0x970500)
#define DTC_BACK_FORWARD_SW_STUCK   ((UINT32)0x970600)
#define DTC_BACK_BACKWARD_SW_STUCK  ((UINT32)0x970700)
#define DTC_SEAT_HALL_SHORT_GND     ((UINT32)0x970900)
#define DTC_SEAT_HALL_SHORT_BAT     ((UINT32)0x970912)
#define DTC_BACK_HALL_SHORT_GND     ((UINT32)0x970B00)
#define DTC_BACK_HALL_SHORT_BAT     ((UINT32)0x970B12)
#define DTC_BCM_MESSAGE_LOST        ((UINT32)0xF81087)

#define PROD_SPEC_DTC_TABLE \
    DTC_BAT_VOL_HIGH,\
    DTC_BAT_VOL_LOW,\
    DTC_CAN_BUS_OFF,\
    DTC_SEAT_FORWARD_SW_STUCK,\
    DTC_SEAT_BACKWARD_SW_STUCK,\
    DTC_BACK_FORWARD_SW_STUCK,\
    DTC_BACK_BACKWARD_SW_STUCK,\
    DTC_SEAT_HALL_SHORT_GND,\
    DTC_SEAT_HALL_SHORT_BAT,\
    DTC_BACK_HALL_SHORT_GND,\
    DTC_BACK_HALL_SHORT_BAT,\
    DTC_BCM_MESSAGE_LOST


/*---------------------------------------------------------------------------*/
/* DEFINE SYMBOLIC NAMES FOR DTC'S HERE.                                     */
/*---------------------------------------------------------------------------*/
#define DTC_ERC_BAT_VOL_HIGH             1
#define DTC_ERC_BAT_VOL_LOW              2
#define DTC_ERC_CAN_BUS_OFF              3
#define DTC_ERC_SEAT_FORWARD_SW_STUCK    4
#define DTC_ERC_SEAT_BACKWARD_SW_STUCK   5
#define DTC_ERC_BACK_FORWARD_SW_STUCK    6
#define DTC_ERC_BACK_BACKWARD_SW_STUCK   7
#define DTC_ERC_SEAT_HALL_SHORT_GND      8
#define DTC_ERC_SEAT_HALL_SHORT_BAT      9
#define DTC_ERC_BACK_HALL_SHORT_GND      10
#define DTC_ERC_BACK_HALL_SHORT_BAT      11
#define DTC_ERC_BCM_MESSAGE_LOST         12


#endif  /* #if(SCM_SEATCONTROL_VARIANT == SCM_R_VARIANT) */

#endif  /*  KERNEL_PRIVATE_DIAG */

/* Not used dtc but configured in application*/
#define ERC_DTC_VALUE_NULL     ((UINT8)0)


#define DTC_STATUS_NVM_DEFAULT_INITIALIZATION \
           { 0x00, 0x00, 0x00, 0x00, 0x00};

/* Range is 0-127 */
#define DTC_FAULT_FOUND_INCR_VAL        ((UBYTE)0x10)
#define DTC_FAULT_NOT_FOUND_DECR_VAL    ((UBYTE)0x20)

/*
__DTC_COUNT_CONFIGURATION(){ }
*/

/*---------------------------------------------------------------------------*/
/* DEFINE NUMBER OF DTC'S HERE.                                              */
/*---------------------------------------------------------------------------*/
#if(SCM_SEATCONTROL_VARIANT == SCM_R_VARIANT)
#define PROD_SPEC_NUMBER_OF_DTCS     16
#else
#define PROD_SPEC_NUMBER_OF_DTCS     12
#endif
#define PROD_SPEC_AVAILABLE_DTC_MASK 0x09

/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DTC_FORMAT_ID                                   */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This MACRO shall give the value of the DTC Format ID      */
/*               that needs to be transmitted to the tester whenever       */
/*               whenever there is a request to transmit the number of     */
/*               DTCs. Please refer the CANDELLA File to get this value    */
/*                                                                         */
/* REQUIRED:     Yes                                                       */
/*               0x00 - ISO14229CompliantDTCFormat                         */
/*               0x01 - SAEJ1939CompliantDTCFormat                         */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#define PROD_SPEC_DTC_FORMAT_ID 0x00

#ifdef  KERNEL_RESTRICTED_DIAG

#endif  /*  KERNEL_RESTRICTED_DIAG  */

/*
__SUPPORTED_EXTENDED_DATA_CONFIGURATION(){ }
*/
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_AVAILABLE_DTC_MASK_RECORD                       */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This MACRO shall represent the DTC mask record that is    */
/*               supported by the application specific server. This info   */
/*               needs to be provided by looking at the candella file      */
/*               The candella file has a separate instance for the Status  */
/*               mask supported. For every status bit that is supported    */
/*               define the value or else disable it                        */
/*                                                                         */
/* REQUIRED:     Yes                                                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
/* Enabled only Mointoring cycle2 and fault detection counter for S197*/
#define YES 0x01
#define NO  0x00

#define MC1_SUPPORTED		   NO	/* Monitoring Cycle Counter 1 */
#define MC2_SUPPORTED		   NO /* Monitoring Cycle Counter 2 */
#define MC3_SUPPORTED		   NO   /* Monitoring Cycle Counter 3 */
#define MC4_SUPPORTED		   NO	/* Monitoring Cycle Counter 4 */
#define FDC_STORAGE_NVM		   NO		/* Fault Detection Counter */
#define FPC_SUPPORTED		   NO  /* Fault Pending Counter */
#define AGED_COUNTER_SUPPORTED NO /* counter of the times that a DTC
                                      has been aged since the last DTC clearing was
                                      carried out */

/* No. of MC and FDC supported */
#define NUM_OF_ADDITIONAL_MC_SUPPORTED 0

/*
__ENVIRONMENT_DATA_CONFIGURATION(){ }
*/
/* Environment data support */
#define GLOBAL_DATA_SUPPORTED  NO
#define LOCAL_DATA_SUPPORTED   NO

/*
__ENVIRONMENT_DATA_CONFIGURATION(){ }
*/
/* The below macro is used to configure whether the environmental data should be updated in NVM
for the first occurence or latest occurence of DTC */
#define ENV_UPDATE_LATEST  YES

/* Global data size configuration */
#if (GLOBAL_DATA_SUPPORTED == YES )
    #define GLOBAL_DATA_SIZE 6
/* This macro refers to from which byte, data should be stored in NVM from the bytes received
from application upon first detection of DTC. Define as zero if we want to save the data from first byte itself 
For example, if you define GLOBAL_DATA_SIZE as 6, out of which first 3 bytes alone need to stored 
in NVM for the first occurence of DTC, then define GD_FO_START_BYTE as 0 and GD_FO_SIZE as 3 */
    #define GD_FO_START_BYTE    0
    #define GD_FO_SIZE          6

    #if (ENV_UPDATE_LATEST == YES)
/* This macro refers to from which byte, data should be stored in NVM from the bytes received
from application upon latest detection of DTC. Define as zero if we want to save the data from first byte itself 
For example, if you define GLOBAL_DATA_SIZE as 6, out of which last 3 bytes alone need to stored 
in NVM for the latest occurence of DTC, then define GD_RO_START_BYTE as 3 and GD_FO_SIZE as 3 */
        #define GD_RO_START_BYTE
        #define GD_RO_SIZE
    #endif
#else
#define GLOBAL_DATA_SIZE 0
#endif

/* Local data size configuration */
#if (LOCAL_DATA_SUPPORTED == YES)
    #define LOCAL_DATA_SIZE 2
    #define LD_FO_START_BYTE 0
    #define LD_FO_SIZE		 2

    #if (ENV_UPDATE_LATEST == YES)
        #define LD_RO_START_BYTE 0
        #define LD_RO_SIZE       2
    #endif
#else
#define LOCAL_DATA_SIZE 0
#endif


/* Define for how many DTCs Monitioring cycle/environment data need to be stored in NVM */
#define NVM_QUEUE_SIZE_MC     PROD_SPEC_NUMBER_OF_DTCS

/* Based on the number of MC parameters, global data and local data support fill the below table */
/* The number of rows should be equal to NVM_QUEUE_SIZE_MC */
/* Number of columns should be equal to NUM_OF_BYTES_TO_STORE */
#define    DTC_MCC_NVM_DEFAULT_INITIALIZATION \
           {0x00 };

/*
__MAX_ONDEMAND_DTC_CONFIGURATION(){ }
*/

#ifdef KERNEL_RESTRICTED_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_MAX_SELF_TEST_DTC                               */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro specifies the largest INDEX that will be       */
/*               logged, when the "KernelLogGGDSError" service is          */
/*               called, while in self test.  Note that this value is      */
/*               used only during self test!  This macro is provided so    */
/*               that logging of selected DTC's can be disabled during     */
/*               self test (this is accomplished by placing the DTC's not  */
/*               be logged during self test at the end of the              */
/*               PROD_SPEC_DTC_TABLE and configuring this macro            */
/*               accordingly).                                             */
/*                                                                         */
/* REQUIRED:     YES. If all DTC's are to be logged during self test, this */
/*               macro must specify the last index in the table.           */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#define PROD_SPEC_MAX_SELF_TEST_DTC  1


#endif  /* KERNEL_RESTRICTED_DIAG */

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_ODC_BUFFER_SIZE                                 */
/*                                                                         */
/* TYPE:         CONSTANT                                                  */
/*                                                                         */
/* DESCRIPTION:  This constant determines the size of the buffer that      */
/*               holds codes generated (via the "KernelLogForkError"       */
/*               service) during diagnostic self-test.                     */
/*                                                                         */
/*               This constant must be large enough to hold all codes that */
/*               can possibly be generated during self-test.  Since some   */
/*               codes are mutually exclusive, it is usually not necessary */
/*               to make this constant equal to the total number of codes  */
/*               that can be generated.  Each DTC logged in this buffer    */
/*               requires 1 byte, so if this constant is 15 a 15 byte      */
/*               buffer is allocated.                                      */
/*                                                                         */
/* REQUIRED:     YES                                                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#define PROD_SPEC_ODC_BUFFER_SIZE   PROD_SPEC_MAX_SELF_TEST_DTC

#endif  /* KERNEL_PRIVATE_DIAG */

/*
__AGING_CNTR_CONFIGURATION(){ }
*/
#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_AGING_COUNT                                     */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro defines the value that should be reached by M2 */
/*               in order to declare a logged DTC as aged. This value      */
/*               could be from 0x40 - 0x80. Once the M2 reached this value */
/*               then the logged DTC shall be declared as aged and the     */
/*               confirmation bit shall be cleared                         */
/*                                                                         */
/* REQUIRED:     YES.                            */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/

#define AGING_PROCESS_SUPPORTED NO /* Define as YES if aging process is supported */
#if (AGING_PROCESS_SUPPORTED == YES)
/*#define PROD_SPEC_AGING_COUNT   64*/
#define PROD_SPEC_AGING_COUNT 39
#endif

/* Select from anyone of the Following for macro FIFO_DATA_USED ->
	MC1
	MC2
	MC3
	MC4
	GLOBAL_DATA
	LOCAL_DATA
Note: Use the same name as mentioned above */
#define		MC1		0x00
#define		MC2		0x01
#define		MC3		0x02
#define		MC4		0x03
#define		GLOBAL_DATA		0x04
#define		LOCAL_DATA		0x05

#define FIFO_DATA_USED MC2 /* Define which data needs to be used to find the most aged DTC */


#define PROD_MC4_EANBLE_DETECT_CYCLE  YES


#if ((FIFO_DATA_USED == GLOBAL_DATA) || (FIFO_DATA_USED == LOCAL_DATA))
#define FIFO_START_INDEX 0 /* Mention from which index the global data for finding the most aged DTC starts */
#define FIFO_DATA_SIZE   3 /* Mention the number of bytes used to find the most aged DTC */
#endif
#endif

/*
__FAULT_PENDING_COUNTER_CONFIGURATION(){ }
*/
#if (FPC_SUPPORTED == YES)
/* Configure the maximum count limit for fault pending counter */
#define PROD_SPEC_FPC_THRESHOLD 1
#endif

/*
__DTC_LOGGING_CONTROL(){ }
*/

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         Prod_Spec_Disable_Error_Logging()                         */
/*                                                                         */
/* TYPE:         MACRO or FUNCTION                                         */
/*                                                                         */
/* DESCRIPTION:  This operation must return a value as follows:            */
/*                                                                         */
/*               TRUE  - logging of trouble codes disabled                 */
/*               FALSE - logging of trouble codes NOT disabled             */
/*                                                                         */
/*               This operation is invoked at run-time to determine        */
/*               if fault code logging should be disabled.  In products    */
/*               were fault code logging does not need to be disabled,     */
/*               this operation should be a macro equated to FALSE.        */
/*                                                                         */
/* REQUIRED:     YES                                                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#define Prod_Spec_Disable_Error_Logging()  (!(inspect_dtc_logging()))


#endif  /* KERNEL_PRIVATE_DIAG */

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         Prod_Spec_Disable_Fault_Clearing()                        */
/*                                                                         */
/* TYPE:         MACRO or FUNCTION                                         */
/*                                                                         */
/* DESCRIPTION:  This operation must return a value as follows:            */
/*                                                                         */
/*               TRUE  - Clearing of trouble codes disabled                */
/*               FALSE - clearing of trouble codes NOT disabled            */
/*                                                                         */
/*               This operation is invoked at run-time to determine        */
/*               if fault code logging should be disabled.  In products    */
/*               were fault code logging does not need to be disabled,     */
/*               this operation should be a macro equated to FALSE.        */
/*                                                                         */
/* REQUIRED:     YES                                                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#define Prod_Spec_Disable_Fault_Clearing()  FALSE/* dgApp_Fault_PreCondition(p_dtc_index_U16) */


#endif  /* KERNEL_PRIVATE_DIAG */

#ifdef KERNEL_RESTRICTED_DIAG
/*-------------------------------------------------------------------------
**
** NAME:         PROD_SPEC_SNAP_SHOT_DTC_COUNT
**
** TYPE:         MACRO
**
** DESCRIPTION:  This macro defines how many DTCs will have snap shot data
**
** REQUIRED:     YES
**
** NOTE:         if no shadow DTCs, define as 0
**
** ACCESS:       KERNEL_PRIVATE_DIAG
**
**-------------------------------------------------------------------------*/
#define PROD_SPEC_SNAP_SHOT_DTC_COUNT  0

#endif  /* KERNEL_RESTRICTED_DIAG */

#ifdef KERNEL_RESTRICTED_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_SNAP_SHOT_DATA                                  */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro defines the snap shot data information for DTCs*/
/*               It has to be filled in the following format               */
/* {dtc_index, snap_event_id, snap_id_bits, &global_data, 10, &local_data, */
/*                                               2}                        */
/*               dtc_index    => DTC index value                           */
/*               snap_event_id  => Supported snap-shot event value         */
/*               snap_id_bits => Supported snap-shot id bit values         */
/*               &global_data => Address of global snap shot data. It is   */
/*                                 application's responsibility to provide */
/*                                 this memory. This could be stored in    */
/*                                 NVM                                     */
/*               10             => Size of global snap shot data           */
/*               &local_data  => Address of global snap shot data. It is   */
/*                                 application's responsibility to provide */
/*                                 this memory. This could be stored in    */
/*                                 NVM                                     */
/*               2              => Size of local snap shot data            */
/*                                                                         */
/* REQUIRED:     YES                                                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#define PROD_SPEC_SNAP_RECORD_1     0x00
#define PROD_SPEC_SNAP_RECORD_2     0x01
#define PROD_SPEC_SNAP_RECORD_3     0x10
#define PROD_SPEC_SNAP_RECORD_4     0x11

#ifdef PROD_SPEC_SNAP_RECORD_1
#define PROD_SPEC_SNAP_SHOT_DATA  \

#endif

#define SNAP_REAL_TIME      ((UBYTE)0x01)
#define SNAP_TOTAL_DIST     ((UBYTE)0x02)
#define SNAP_BATT_SUPPLY    ((UBYTE)0x04)
#define SNAP_ENGINE_STAT    ((UBYTE)0x08)
#define SNAP_INCAR_TEMP     ((UBYTE)0x10)
#define SNAP_OUT_TEMP       ((UBYTE)0x20)

#define PROD_SPEC_SNAP_SHOT_DATA  \

#endif  /* KERNEL_RESTRICTED_DIAG */

/*
__CLEAR_CAN_DIAG_COUNTERS_CONFIGURATION(){ }
*/
#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DTC_CLEAR_FUNCTION_LIST                         */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of all functions that are  */
/*               to be executed upon exit from diagnostics mode.  Functions*/
/*               in this list must match the following prototype:          */
/*                                                                         */
/*                 void function_name(void);                               */
/*                                                                         */
/*               Functions in this list are executed sequentially from the */
/*               first function in the list until the last.                */
/*                                                                         */
/* NOTE:         Functions in this list should return very quickly         */
/*               (maximum execution time much less than 1 millisecond).    */
/*                                                                         */
/* REQUIRED:     YES (however, the list can be NULL)                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#define  PROD_SPEC_DTC_CLEAR_FUNCTION_LIST \


#endif /* KERNEL_PRIVATE_DIAG */    

/*
__EPM01_CONFIGURATION(){ }
*/

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_EPM01_BEING_USED                                */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  The PROD_SPEC_EPM01_BEING_USED Macro specifies            */
/*               whether the EEPROM manager is queuing the request         */
/*               and maintain a shadowed RAM.                              */
/*               This MACRO must be defined if using EPM-01 code package   */
/*               from DI-kernel bookshelf.                                 */
/*                                                                         */
/*               If using in-line type EEPROM manager, do not define       */
/*               this macro.                                               */
/*                                                                         */
/* REQUIRED:     No.                                                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
/*
For use of EPM-01 code package in DI Bookshelf
*/

#define  PROD_SPEC_EPM01_BEING_USED



#endif  /* KERNEL_PRIVATE_DIAG */



#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         Prod_Spec_Eprom_Change_Multiple                           */
/*               PROD_SPEC_NVM_MULTI_BYTE_WRITE                            */
/*                                                                         */
/* TYPE:         FUNCTION and MACRO                                        */
/*                                                                         */
/* DESCRIPTION:  The PROD_SPEC_NVM_MULTI_BYTE_WRITE macro specifies        */
/*               whether or not a multi-byte NVM write function is         */
/*               supported.  When it is defined, multi-byte write          */
/*               is supported; if it is not defined, multi-byte write      */
/*               is not supported.  If multi-byte write is supported,      */
/*               the Prod_Spec_Eprom_Change_Multiple function is used to   */
/*               write bytes to NVM (even if only one byte needs to be     */
/*               written).                                                 */
/*               The prototype for the function is as follows:             */
/*                                                                         */
/*               void Prod_Spec_Eprom_Change_Multiple(                     */
/*                       UBYTE *ctcodes_address,                           */
/*                       UBYTE *new_values,                                */
/*                       UBYTE values_to_update);                          */
/*                                                                         */
/*                 ctcodes_address = address to start writing in ctcodes   */
/*                 new_values      = address of bytes to be written to     */
/*                                   ctcodes                               */
/*                 values_to_update= number of bytes to written to ctcodes */
/*                                                                         */
/*               In essence, "values_to_update" bytes are to be written    */
/*               to "ctcodes" starting at "ctcodes_address".  The values   */
/*               come from consecutive locations pointed to by             */
/*               "new_values".                                             */
/*                                                                         */
/*               If PROD_SPEC_NVM_MULTI_BYTE_WRITE is not defined,         */
/*               bytes are written to NVM one byte at a time using         */
/*               Prod_Spec_Eprom_Change.                                   */
/*                                                                         */
/* REQUIRED:     YES when multiple bytes NVM write is supprted.            */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/

/*
For use of EPM-01 code package in DI Bookshelf
*/
/*#include "epm_pkg.h"*/
#define  PROD_SPEC_NVM_MULTI_BYTE_WRITE

#define  Prod_Spec_Eprom_Change_Multiple(ctcodes_address, new_values, values_to_update)

#endif  /* KERNEL_PRIVATE_DIAG */


#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         Prod_Spec_Eprom_Change(value, address)                    */
/*                                                                         */
/* TYPE:         MACRO or FUNCTION                                         */
/*                                                                         */
/* DESCRIPTION:  This operation must change the contents of the EEPROM     */
/*               location as specified by the "address" parameter to the   */
/*               value specified by the "value" parameter.  If the         */
/*               requested value is already present, the location must     */
/*               not be re-programmed! (keeps EEPROM read/write cycles to  */
/*               a minimum).                                               */
/*                                                                         */
/* REQUIRED:     YES                                                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
/*
For use of EPM-01 code package in DI Bookshelf
*/
/*#include "epm_pkg.h"*/
#define  PROD_SPEC_NVM_MULTI_BYTE_WRITE

#define  Prod_Spec_Eprom_Change(value,address)


#endif  /* KERNEL_PRIVATE_DIAG */



#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         Prod_Spec_Eprom_Byte_Erase(address)                       */
/*                                                                         */
/* TYPE:         MACRO or FUNCTION                                         */
/*                                                                         */
/* DESCRIPTION:  This operation must erase the EEPROM byte at the location */
/*               specified by the "address" parameter to a value of 0xFF.  */
/*				 Please use epm_inline_prog_byte() of epm_pakage	       */
/*                                                                         */
/* REQUIRED:     YES.                                                      */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
/*
For use of EPM-01 code package in DI Bookshelf
*/
/*#include "epm_pkg.h"*/
#define  Prod_Spec_Eprom_Byte_Erase(address, value) 

#endif  /* KERNEL_PRIVATE_DIAG */

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         Prod_Spec_Eprom_Erase                                     */
/*                                                                         */
/* TYPE:         FUNCTION                                                  */
/*                                                                         */
/* DESCRIPTION:  This operation will let EEPROM manager to queue a         */
/*               request to erase EEPROM and get call back if the          */
/*               erase is finished. The parameter of the call back         */
/*               is 0 if erase fail, non zero if erase succeed.            */
/*                                                                         */
/*               The prototype for the function is as follows:             */
/*                                                                         */
/*               void Prod_Spec_Eprom_Erase(                               */
/*                   UBYTE *ctcodes_address, -target address               */
/*                   UBYTE *new_values,      -new value buffer address     */
/*                   void  *cb_address,      -call back function address   */
/*                   UBYTE values_to_update);-number of bytes in buffer    */
/*                                                                         */
/* REQUIRED:     YES if PROD_SPEC_EPM01_BEING_USED is defined.             */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#ifdef PROD_SPEC_EPM01_BEING_USED
/*#include "epm_pkg.h"*/
#define  Prod_Spec_Eprom_Erase(ctcodes_address, new_values, cb_address, values_to_update) 

#endif  /* PROD_SPEC_EPM01_BEING_USED */


#endif  /* KERNEL_PRIVATE_DIAG */



#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_EPM_MAX_NUM_MODIFY                              */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro is the length of queue of EPM-01.              */
/*               The value of this macro has to be equal to                */
/*               EPM_MAX_NUM_MODIFY in "epm_pkg.cfg"                       */
/*                                                                         */
/* REQUIRED:     YES if PROD_SPEC_EPM01_BEING_USED is defined.             */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#ifdef PROD_SPEC_EPM01_BEING_USED

#define PROD_SPEC_EPM_MAX_NUM_MODIFY   32

#endif  /* PROD_SPEC_EPM01_BEING_USED */


#endif  /* KERNEL_PRIVATE_DIAG */

/*
__DIAG_UTIL(){ }
*/

#define KWP2K_DIAG_IS_BIT_SET(operand,mask)	(TESTBIT((operand) , (mask)) ? 1 : 0)

/*
__Network_Interface_functions(){ }
*/
#define KernelLogRefineError        diag_log_error
#define KernelClearRefineError      diag_clear_error

#define diag_DiagMode14CallBack     DiagMode14CallBack

#if (GLOBAL_DATA_SUPPORTED == YES)
#endif


#endif




