#ifndef DIAG_KWP2K_DI_CORE_MGR_CFG
#define DIAG_KWP2K_DI_CORE_MGR_CFG
/*---------------------------------------------------------------
** Include files for GLOBAL configuration items go here.
**---------------------------------------------------------------*/
#include "system.h"
#include "string.h"

#include "vnim_diag.h"
#include "vnim_if.h"

#include "fdiag.h"
#include "diag_kwp2k_di_core_erlg.h"
#include "diag_kwp2k_di_core_mgr.h"
#include "diag_kwp2k_di_core_erlg.cfg"


//#define PROD_SPEC_FSM_CONFIGURE

/***************************************************************************
   P U B L I C   M A C R O   A N D   T Y P E   D E F I N I T I O N S
***************************************************************************/
/*
___Diagnostics_buffer_(){ }
*/
/*Network Max Buffer Size*/
#define NW_MAX_BUFF_LENGTH                            ((DG_MGR_UINT8)250)

/*
___Negative_Response_Code_configuration(){ }
*/

/*--------------------------------**
** Negative Response Code **
**--------------------------------*/
#define kwp2k_diag_NrcGeneralReject                                        0x10
#define kwp2k_diag_NrcServiceNotSupported                                  0x11
#define kwp2k_diag_NrcSubfunctionNotSupported                              0x12
#define kwp2k_diag_NrcInvalidFormat                                        0x13     
#define kwp2k_diag_NrcBusyRepeatRequest                                    0x21
#define kwp2k_diag_NrcConditionsNotCorrect                                 0x22
#define kwp2k_diag_NrcRoutineNotCompleted                                  0x23
#define kwp2k_diag_NrcRequestSequenceError                                 0x24
#define kwp2k_diag_NrcRequestOutOfRange                                    0x31
#define kwp2k_diag_NrcGeneralProgrammingFailure                            0x72      
#define kwp2k_diag_NrcResponsePending                                      kwp2k_diag_NrcBusyRepeatRequest           /*Renault Specific*/
#define kwp2k_diag_NrcSubfunctionNotSupportedInActiveSession               0x7E
#define kwp2k_diag_NrcServiceNotSupportedInActiveSession                   0x7F

#define kwp2k_diag_NrcAccessDenied                                         0x33
#define kwp2k_diag_NrcIOCTLRequestOutOfRange                               0x31
#define kwp2k_diag_NrcCommCtrlRequestOutOfRange                            0x31
#define kwp2k_diag_NrcSecurityRequestOutOfRange                            0x31
#define kwp2k_diag_NrcDIDRequestOutOfRange                                 0x31
#define kwp2k_diag_NrcDTCRequestOutOfRange                                 0x31
#define kwp2k_diag_NrcServiceRequiredTimeDelayNotExpired                   0x37
#define kwp2k_diag_NrcRequestExceededNumberOfAttempts                      0x36
#define kwp2k_diag_NrcRequestInvalidKey                                    0x35
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         Select Service Macros                                     */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  The following macros are defined to select which services */
/*               are going to be supported for a particular application.   */
/*               Comment the definition of services which are not required.*/
/*                                                                         */
/* REQUIRED:     YES.                                                      */
/*                                                                         */
/* ACCESS:       GLOBAL                                                    */
/*                                                                         */
/*-------------------------------------------------------------------------*/

/*
___Service_10_configuration(){ }
*/

/****************************************************
** Diagnostic sessions supported
****************************************************/
#define MODE_10_SUPPORTED                  /* Default/Extended diagnostic sessions */
#define MODE_10_SUBFUNC_02_SUPPORTED       /*   Programming Session */

/*
____DIAG_SESSION_TABLE(){ }
*/

/*
	{session_value		, session index, entry_deny_fptr, prolog_fptr, epilog_fptr, abort_fptr}
*/
/*				session index							  */
/* 				#define DG_EXTENDED			0x02	      */
/* 				#define DG_PROGRAMMING		0x04	      */
/* 				#define DG_SESS_1			0x08	      */
/* 				#define DG_SESS_2			0x10	      */
/* 				#define DG_SESS_3			0x20	      */
/* 				#define DG_SESS_4			0x40		  */
/* 				#define DG_SESS_5			0x80		  */

/*
Do not configure for Default Session. Default session is handled within the core.
Each session should have a unique session_index
*/

#define PROD_SPEC_DIAG_SESSION_TABLE                 \
	{kwp2k_diag_session_extended	, DG_EXTENDED	, NULL_PTR, fdiag_extended_prolog, fdiag_extended_epilog, fdiag_diag_exit_session_check},\
{kwp2k_diag_session_programming	, DG_PROGRAMMING, NULL_PTR, Prod_Spec_Mode10_02_Handler, NULL_PTR, NULL_PTR},


/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DENY_PROG_SESS_LIST                             */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of all functions that are  */
/*               to be executed to decide whether programming session can  */
/*               can be entered or not.                                    */
/*               Any tasks that have conditions which can prevent from     */
/*               entering programming session are to be listed here.       */
/*               Functions in this list must match the following prototype.*/
/*                                                                         */
/*                 BOOLEAN function_name_KSDenyProgSess(void);             */
/*                                                                         */
/*               The values returned by functions in this list must be as  */
/*               follows:                                                  */
/*                                                                         */
/*                 FALSE if ok to enter Programming Session                */
/*                 TRUE  if not ok to enter    .                           */
/*                                                                         */
/*               If any function in the list returns TRUE, entry to prog   */
/*               session is aborted and negative response is sent.         */
/*                                                                         */
/*               Functions in this list are executed sequentially from the */
/*               first function in the list until the last.                */
/*                                                                         */
/* REQUIRED:     YES.(List can be NULL)                                    */
/*                                                                         */
/* ACCESS:       None                                                      */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#define PROD_SPEC_DENY_PROG_SESS_LIST  

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         void Prod_Spec_Mode10_02_Handler(void)                    */
/*                                                                         */
/* TYPE:         Function                                                  */
/*                                                                         */
/* DESCRIPTION:  If the mode 0x02 for the service 0x10 is supported then   */
/*               the application must provide a function                   */
/*                       void Prod_Spec_Mode10_02_Handler(void)            */
/*               which will be called when submode 02 is entered.          */
/*                                                                         */
/* REQUIRED:     YES.                                                      */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
//#ifdef MODE_10_SUBFUNC_02_SUPPORTED
//extern UINT8 Prod_Spec_Mode10_02_Handler(void);
//#endif

#endif  /* KERNEL_PRIVATE_DIAG */

/*
___Service_20_configuration(){ }
*/

/****************************************************
** stopDiagnosticSession
****************************************************/
/*#define MODE_20_SUPPORTED*/                  

/*
___Service_11_configuration(){ }
*/

/****************************************************
** Ecu Reset service supported
****************************************************/
#define MODE_11_SUPPORTED
#define MODE_11_SUBFUNC_01_SUPPORTED    
//#define MODE_11_SUBFUNC_02_SUPPORTED   
#define MODE_11_SUBFUNC_03_SUPPORTED    
//#define MODE_11_ECU_RESETRESP_TIMER_SUPPORTED
/*#define MODE_11_SUBFUNC_04_SUPPORTED       EnableRapidPowerShutDown*/
/*#define MODE_11_SUBFUNC_05_SUPPORTED    DisableRapidPowerShutDown*/


#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_ECU_RESET_HARD                                  */
/*               PROD_SPEC_ECU_RESET_SOFT                                  */
/*               PROD_SPEC_ECU_RESET_KEYOFFON                              */
/*               PROD_SPEC_ECU_RESET_DSBL_SHUTDOWN                         */
/*               PROD_SPEC_ECU_RESET_ENBL_SHUTDOWN                         */
/*                                                                         */
/* TYPE:         MACROS                                                    */
/*                                                                         */
/* DESCRIPTION:  These macros has to be filled with the function to be     */
/*               called if the EcuReset request is received with reset type*/
/*               function and positive response was sent successfully      */
/*                                                                         */
/*               The prototype should be of the format                     */
/*                  void functname(void);                                  */
/*                                                                         */
/*               Define only those which are supported in your program and */
/*               leave empty for others                                    */
/*                                                                         */
/* REQUIRED:     YES.                                                      */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#ifdef MODE_11_SUBFUNC_01_SUPPORTED
#define PROD_SPEC_ECU_RESET_HARD                COP_fail(0x11);
#endif

#ifdef MODE_11_SUBFUNC_02_SUPPORTED
#define PROD_SPEC_ECU_RESET_KEYOFFON
#endif

#ifdef MODE_11_SUBFUNC_03_SUPPORTED
#define IEH_ECURESET         0xD1u             /* ECU RESET COMMAND FROM DIAG*/
#define PROD_SPEC_ECU_RESET_SOFT              COP_fail(IEH_ECURESET); //COP_failure_init_C();/* COP_fail(IEH_ECURESET);*/
#endif

#ifdef MODE_11_SUBFUNC_04_SUPPORTED
#define PROD_SPEC_ECU_RESET_ENBL_SHUTDOWN
#endif

#ifdef MODE_11_SUBFUNC_05_SUPPORTED
#define PROD_SPEC_ECU_RESET_DSBL_SHUTDOWN
#endif

#endif /* KERNEL_PRIVATE_DIAG */

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DENY_ECU_RESET_LIST                             */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of all functions that are  */
/*               to be executed when a ECU-RESET command is received.      */
/*               Any tasks that have conditions which can prevent from     */
/*               triggering the ECU RESET  are to be listed here.          */
/*               Functions in this list must match the following prototype.*/
/*                                                                         */
/*                 BOOLEAN function_name_KSDenyEcureset(void);             */
/*                                                                         */
/*               The values returned by functions in this list must be as  */
/*               follows:                                                  */
/*                                                                         */
/*                 FALSE if ok to execute ECU-RESET.                       */
/*                 TRUE  if not ready for reset.                           */
/*                                                                         */
/*               If any function in the list returns TRUE, ECU RESET is    */
/*               aborted and negative response is sent.                    */
/*                                                                         */
/*               Functions in this list are executed sequentially from the */
/*               first function in the list until the last.                */
/*                                                                         */
/* REQUIRED:     YES.(List can be NULL)                                    */
/*                                                                         */
/* ACCESS:       KERNEL_RESTRICTED_DIAG                                    */
/*                                                                         */
/*-------------------------------------------------------------------------*/

#define PROD_SPEC_DENY_ECU_RESET_LIST  \


#endif /* KERNEL_PRIVATE_DIAG */

/*
___Error_Handler_Definition(){ }
*/
/* Define below macro if error handler is supported */
#define ERROR_HANDLER_SUPPORTED 

#ifdef ERROR_HANDLER_SUPPORTED

/*
___Service_14_configuration(){ }
*/

/****************************************************
** ClearDTCInformation service supported
****************************************************/
/* Define either one of the below macro */
#define MODE_14_UDS_SUPPORTED
/* #define MODE_14_KWP_SUPPORTED */


/* Define below macro if application specific subfunction is supported */
/* #define MODE_14_PROD_SPEC_SUBFUNC */

#ifdef MODE_14_PROD_SPEC_SUBFUNC
#define Prod_Spec_14_app_spec_subfunc(bufptr) \
		fdiag_ser_14_app_spec_subfunc(bufptr)

#endif

/*
___Service_17_configuration(){ }
*/
/****************************************************
** ReadStatusOfDiagnosticTroubleCodes service supported
****************************************************/
/*#define MODE_17_SUPPORTED*/

#ifdef MODE_17_SUPPORTED

/* Define below macro if application specific sub-function needs to be supported */
/* #define MODE_17_PROD_SPEC_SUBFUNC */

#ifdef MODE_17_PROD_SPEC_SUBFUNC
#define Prod_Spec_17_app_spec_subfunc(bufptr) \
        fdiag_ser_17_app_spec_subfunc(bufptr)
#endif

/* Define below macro if system supplier data is supported for Service $17.
If not supported disable the below macro */
/* #define MODE_17_SUPPLIER_DATA_SUPPORTED */

#ifdef MODE_17_SUPPLIER_DATA_SUPPORTED    /* supplier data not supported */
#define  Prod_Spec_Env_Data_Ser_17( bufptr )

#endif /* MODE_17_SUPPLIER_DATA_SUPPORTED */

/* Define below macro if application specific dtc status need to be supported.
If not supported disable the below macro */
#define MODE_17_PROD_SPEC_DTC_STATUS

#ifdef MODE_17_PROD_SPEC_DTC_STATUS  /* DTC status is supported by application */
#define  Prod_Spec_Dtc_Status_Ser_17(index)  \
		 fdiag_dtc_status_ser_17(index)

#endif /* MODE_17_PROD_SPEC_DTC_STATUS */

#endif /* MODE_17_SUPPORTED */

/*
___Service_18_configuration(){ }
*/
/****************************************************
** readDiagnosticTroubleCodesByStatus service supported
****************************************************/
/*#define MODE_18_SUPPORTED */
/*#define MODE_18_SUBFUNC_00_SUPPORTED*/  /* REPORT_IDENTIFIED_BCD_DTC */
/*#define MODE_18_SUBFUNC_01_SUPPORTED */ /* REPORT_SUPPORTED_BCD_DTC */
/*#define MODE_18_SUBFUNC_02_SUPPORTED */ /* REPORT_IDENTIFIED_HEX_DTC */
/*#define MODE_18_SUBFUNC_03_SUPPORTED */ /* REPORT_SUPPORTED_HEX_DTC */
/*#define MODE_18_SUBFUNC_APP_SPEC_SUPPORTED*/  /* Define this macro if any application specific subfunction needs to be supported */

#ifdef MODE_18_SUBFUNC_APP_SPEC_SUPPORTED   /* $18 is not supported */
/* Application needs to take care of sending positive/negative response if this macro is defined */
#define Prod_Spec_18_app_spec_subfunc(subfunc_param)\
		fdiag_ser_18_app_spec_subfunc(subfunc_param)
#endif

/* Define below macro if application specific dtc status need to be supported.
If not supported disable the below macro */
#define MODE_18_PROD_SPEC_DTC_STATUS

#ifdef MODE_18_PROD_SPEC_DTC_STATUS
#define  Prod_Spec_Dtc_Status_Ser_18(index)  \
		 fdiag_dtc_status_ser_18(index)	   

#endif /* MODE_18_PROD_SPEC_DTC_STATUS */

/*
___Service_19_configuration(){ }
*/

/****************************************************
** ReadDTCInformation service supported
****************************************************/
#define MODE_19_SUPPORTED
#define MODE_19_SUBFUNC_01_SUPPORTED  /* reportNumberOfDTCByStatusMask */
#define MODE_19_SUBFUNC_02_SUPPORTED  /* reportDTCByStatusMask */
//#define MODE_19_SUBFUNC_03_SUPPORTED  /* reportDTCSnapshotIdentification */
//#define MODE_19_SUBFUNC_04_SUPPORTED  /*    reportDTCSnapshotRecordByDTCNumber */
//#define MODE_19_SUBFUNC_05_SUPPORTED  /* reportDTCSnapshotRecordByRecordNumber */
//#define MODE_19_SUBFUNC_06_SUPPORTED  /* reportDTCExtendedDataRecordByDTCNumber */
#define MODE_19_SUBFUNC_0A_SUPPORTED  /* reportSupportedDTC */
//#define MODE_19_SUBFUNC_0F_SUPPORTED  /* reportMirrorMemoryDTCByStatusMask */
//#define MODE_19_SUBFUNC_10_SUPPORTED  /* reportMirrorMemoryDTCExtendedDataRecordByDTCNumber */
//#define MODE_19_SUBFUNC_11_SUPPORTED  /* report number of mirror memory DTC by status  mask */
/*#define MODE_19_SUBFUNC_0E_SUPPORTED*/  /* report most recent confirmed DTC */
//#define MODE_19_SUBFUNC_14_SUPPORTED	  /* Report DTC Fault Detection Counter */

#ifdef MODE_19_SUBFUNC_04_SUPPORTED
//#define Prod_Spec_Ser_19_Subfunc_04(index) \
//		 fdiag_Ser_19_Subfunc_04(index)
#endif


/*
___Service_85_configuration(){ }
*/

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DENY_DTCTL_ENTRY_LIST                           */
/*                                                                         */
/* TYPE:         MACRO and FUNCTIONS                                       */
/*                                                                         */
/* DESCRIPTION:  The macro PROD_SPEC_DENY_DTCTL_ENTRY_LIST must contain    */
/*               a list of all functions that are to be executed BEFORE    */
/*               entering NO DTC log state via diagnostic command of       */
/*               Control DTC Setting. Any tasks that have conditions which */
/*               can prevent no DTC log state being entered must register  */
/*               (place) a function here.                                  */
/*               Functions in this list must match the following prototype:*/
/*                                                                         */
/*                 BOOLEAN function_name_KSDenyDtctl(void);                */
/*                                                                         */
/*               The values returned by functions in this list must be as  */
/*               follows:                                                  */
/*                                                                         */
/*                 TRUE if no DTC log state CANNOT be entered.             */
/*                 FALSE if OK to enter no DTC log state.                  */
/*                                                                         */
/*               Functions in this list are executed sequentially from the */
/*               first function in the list until the last.                */
/*                                                                         */
/*               If any function in the list returns TRUE, No DTC          */
/*               log state will NOT be entered (response message           */
/*               indicating "conditions not correct" will be sent to the   */
/*               tester).                                                  */
/*				 PROD_SPEC_DENY_DTCTL_SUP_SESSION						   */
/* 					- Configure the sessions inwhich $85 is supported	   */
/*						#define NO_SESSIONCHECK 	0x00				   */	
/* 						#define DG_DEFAULT 			0x01	               */
/* 						#define DG_EXTENDED			0x02	               */
/* 						#define DG_PROGRAMMING		0x04	               */
/* 						#define DG_SESS_1			0x08	               */
/* 						#define DG_SESS_2			0x10	               */
/* 						#define DG_SESS_3			0x20	               */
/* 						#define DG_SESS_4			0x40	               */
/* 						#define DG_SESS_5			0x80	               */
/*                                                                         */
/*                                                                         */
/* NOTE:         Functions in the list PROD_SPEC_DENY_DTCTL_ENTRY_LIST     */
/*               should return very quickly (maximum execution time much   */
/*               less than 1 millisecond).                                 */
/*                                                                         */
/* REQUIRED:     YES when mode 0x85 is supported through the configuration */
/*               of FNOS (however, the list can be NULL)                   */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/

#define MODE_85_SUPPORTED

#define  PROD_SPEC_DENY_DTCTL_SUP_SESSION (DG_EXTENDED)
#define  PROD_SPEC_DENY_DTCTL_ENTRY_LIST    

#define kwp2k_diag_fdtc_app_enable_dtc()                    {Enable_dtc_logging = TRUE;}
#define kwp2k_diag_fdtc_app_disable_dtc()                   {Enable_dtc_logging = FALSE;}

#define MODE_85_SUPPORTED_BASED_ON   ISO_14229_BASED

	#if (MODE_85_SUPPORTED_BASED_ON == APPL_SPECIFIC)
	/* Declare below function in the respective application header file 
	   EXTERN UINT8 dg_app_ctrl_dtc_format(UINT8 *bufptr, UINT16 dataLen, UINT8 *resp_len, UINT8 *ctrl_state); 
	   Application should return the response status -> 0x01 (Positive response), 0x00(negative response) 
	   *bufptr -> Check this buffer for the request data and fill the response data in the same buffer itself 
	   dataLen -> Use this to check the Request length 
	   *resp_len -> Fill this with the response data length
	   *ctrl_state -> Update the control status in this pointer. 0x00(No Control), 0x01(Enable DTC setting), 0x02(Disable DTC setting) */

	/* Core will take care of sending the response depending on the return status */

	    #define Prod_Spec_appl_specific_ctrl_dtc_format(bufptr,dataLen,resp_len,ctrl_state) \
				dg_app_ctrl_dtc_format((void *)bufptr, dataLen, (void *)resp_len, (void *)ctrl_state)

	#endif


#endif  /* KERNEL_PRIVATE_DIAG */

#endif	/*ERROR_HANDLER_SUPPORTED*/
/*
___Service_3E_configuration(){ }
*/

/****************************************************
** Tester Present supported.
****************************************************/
#define MODE_3E_SUPPORTED


/*
___Service_27_configuration(){ }
*/

/*-------------------------------------------------------------------------*/
/*                           SecurityAccess			                       */
/*-------------------------------------------------------------------------*/
#define MODE_27_SUPPORTED
#define VM_REQUEST_SEED 	0x01
#define VM_SEND_KEY   		0x02
#define VM_SEED_LENGTH		0x04
#define VM_KEY_LENGTH		0x04

#define PROD_SPEC_DIAG_27_LIST \
   {VM_REQUEST_SEED, VM_SEND_KEY, VM_SEED_LENGTH, VM_KEY_LENGTH, fdiag_get_seed, fdiag_verify_key}	,\


/*
___Service_28_configuration(){ }
*/

/*-------------------------------------------------------------------------*/
/*                           Communication Control                         */
/*-------------------------------------------------------------------------*/
#define MODE_28_SUPPORTED

#ifdef MODE_28_SUPPORTED
#define ENRX_ENTX           0
#define ENRX_DISENTX        1
#define DISENRX_ENTX        2
#define DISENRX_DISENTX     3

#define ENRX_ENTX_NO_REP           0x80
#define DISENRX_DISENTX_NO_REP     0x83


#define APP_MSG             1
#define NM_MSG              2
#define APP_NM_MSG          3
#endif

/*
___Service_1A_configuration(){ }
*/

/***************************************************************************/
/*              ReadEcuIdentification (0x1A) support.                       */
/***************************************************************************/
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DIAG_ECU_ID_TABLE                                  */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of entries for product     */
/*               specific EcuIdentification. Each entry must contain six   */
/*               items as follows:                                         */
/*                                                                         */
/*         {id, valid_modes, buffer_ptr, buffer_length, function_ptr,      */
/*          response_data_handler,supported_session}                       */
/*                                                                         */
/*               id         = 8-bit PID                                  */
/*               buffer_ptr  = pointer to a memory buffer of the PID...    */
/*                             USED ONLY IF "buffer_length" IS NON-ZERO.   */
/*               buffer_length = length of buffer pointed to by            */
/*                               "buffer_ptr" -OR- ZERO                    */
/*               function_ptr = pointer to function to call to fetch PID   */
/*                              bytes...USED ONLY IF "buffer_length" IS    */
/*                              ZERO.                                      */
/*              response_data_handler = whether response should be handled */
/*              by application or core (APPL_HANDLE or CORE_HANDLE)        */
/*              supported_session = sessions supported by LID              */
/*                                                                         */
/*               If "buffer_length" is non-zero, "buffer_ptr" will be      */
/*               used as a pointer to a memory buffer and "buffer_length"  */
/*               bytes will be fetched from the buffer and used to send a  */
/*               response message to the tester.                           */
/*                                                                         */
/*               If "buffer_length" is zero, the function pointed to by    */
/*               "function_ptr" is called to fetch the data.  The          */
/*               prototype for this function must be as follows:           */
/*                                                                         */
/*                 UCHAR function_name_KSGetPID(void *buffer);             */
/*                                                                         */
/*                 buffer - address of memory buffer where the called      */
/*                          function must place the pid data               */
/*                                                                         */
/*               The value returned by the function must be the number of  */
/*               bytes placed in the buffer (which represents the length   */
/*               of the PID).  The data length of the PID MUST NOT be      */
/*               greater than the (diag buffer length - 3).  The data      */
/*               the   function places in the buffer                       */
/*               is used to send a response message to the tester.  A      */
/*               return value of 0 may also be used to indicate that       */
/*               under the currently selected option settings, the PID     */
/*               is not supported.  In this case, a negative response      */
/*               code of 0x22 (condition not correct) will be sent         */
/*               instead of a PID response message.                        */
/*                                                                         */
/*               If "response_data_handler" is mentioned as APPL_HANDLE    */
/*               application should take care of checking all the possible */
/*               negative response and core will not handle it */
/*                                                                         */
/*      Example: End-item with 3 PIDs.  The first pid is created by        */
/*               calling "pid_1_function".  Pids 2 and 3 are fetched from  */
/*               "pid_2_buffer" (length=3 bytes) and "pid_3_buffer"        */
/*               (length=2 bytes) respectively.                            */
/*                Also PID 0x01 response is handled by Core and it is      */
/*                in 2 sessions. PIDs 0x02 and 0x03 responses are handled  */
/*                by application and it is supported in only one session   */
/*                                                                         */
/*               #define    PROD_SPEC_DIAG_PID_TABLE  \                    */
/*                {0x01, (void *) 0, 0, pid_1_function, CORE_HANDLE, (EXTENDEDSUBFUNC|SUPPLIERSUBFUNC)}, \ */
/*                {0x02, &pid_2_buffer,   3, (void *) 0, APPL_HANDLE, NO_SESSIONCHECK },                 \ */
/*                {0x03, &pid_3_buffer,   2, (void *) 0}, APPL_HANDLE, NO_SESSIONCHECK },                \ */
/*                                                                         */
/*               Functions in this list are executed only when the         */
/*               associated PID has been requested by a diagnostics        */
/*               message.                                                  */
/*                                                                         */
/* NOTE:         The following PIDS are universal and defined inside the   */
/*               kernel...DON'T configure here.                            */
/*               0xD100, 0x0200, 0x0202, 0xE200, 0xC900, 0xC901, 0xE6F2,   */
/*               0xE6F3                                                    */
/*                                                                         */
/* REQUIRED:     YES when mode 0x1A is supported through the configuration */
/*               of FNOS (however, the list can be NULL)                   */
/*                                                                        */
/* ACCESS:                                                                 */
/*                                                                         */
/*-------------------------------------------------------------------------*/
/* ======================================================================= */
/*                 BIT MAPPED PIDS                                         */
/* Kernel Controlled - None                                                */
/* ======================================================================= */
/*#define MODE_1A_SUPPORTED */

/* Note: If configured as APPL_HANDLE, then always configure function_ptr and handle
positive or negative response in the application */

#define GET_SYSTEM_IDENTIFICATION                   ((UINT8) 0x80u)
#define GET_TEMP_VARIABLE							((UINT8) 0x90u)
#define GET_TEMP_VARIABLE_1							((UINT8) 0x81u)

/*
____DIAG_ECU_ID_TABLE(){ }
*/

#define PROD_SPEC_DIAG_ECU_ID_TABLE                 \
/*	{GET_SYSTEM_IDENTIFICATION                  ,(void *) 0, 0, dg_app_80_GET_SYSTEM_IDENTIFICATION, CORE_HANDLE, NO_SESSIONCHECK} ,\
	{GET_TEMP_VARIABLE_1		                ,(void *) 0, 0, dg_app_81_GET_SYSTEM_IDENTIFICATION, CORE_HANDLE, NO_SESSIONCHECK} ,\
	{GET_TEMP_VARIABLE_2						,&temp_var[0],0x03,(void *) 0, CORE_HANDLE, NO_SESSIONCHECK} ,\
*/	
/*Sample*/ 

/*
___Service_21_configuration(){ }
*/
/***************************************************************************/
/*              ReadDataByLocalIdentifier (0x21) support.                  */
/***************************************************************************/
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DIAG_LID_TABLE                                  */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of entries for product     */
/*               specific EcuIdentification. Each entry must contain six   */
/*               items as follows:                                         */
/*                                                                         */
/*         {id, valid_modes, buffer_ptr, buffer_length, function_ptr,      */
/*          response_data_handler,supported_session}                       */
/*                                                                         */
/*               id         = 8-bit PID                                    */
/*               buffer_ptr  = pointer to a memory buffer of the PID...    */
/*                             USED ONLY IF "buffer_length" IS NON-ZERO.   */
/*               buffer_length = length of buffer pointed to by            */
/*                               "buffer_ptr" -OR- ZERO                    */
/*               function_ptr = pointer to function to call to fetch PID   */
/*                              bytes...USED ONLY IF "buffer_length" IS    */
/*                              ZERO.                                      */
/*              response_data_handler = whether response should be handled */
/*              by application or core (APPL_HANDLE or CORE_HANDLE)        */
/*              supported_session = sessions supported by LID              */
/*                                                                         */
/*               If "buffer_length" is non-zero, "buffer_ptr" will be      */
/*               used as a pointer to a memory buffer and "buffer_length"  */
/*               bytes will be fetched from the buffer and used to send a  */
/*               response message to the tester.                           */
/*                                                                         */
/*               If "buffer_length" is zero, the function pointed to by    */
/*               "function_ptr" is called to fetch the data.  The          */
/*               prototype for this function must be as follows:           */
/*                                                                         */
/*                 UCHAR function_name_KSGetPID(void *buffer);             */
/*                                                                         */
/*                 buffer - address of memory buffer where the called      */
/*                          function must place the pid data               */
/*                                                                         */
/*               The value returned by the function must be the number of  */
/*               bytes placed in the buffer (which represents the length   */
/*               of the PID).  The data length of the PID MUST NOT be      */
/*               greater than the (diag buffer length - 3).  The data      */
/*               the   function places in the buffer                       */
/*               is used to send a response message to the tester.  A      */
/*               return value of 0 may also be used to indicate that       */
/*               under the currently selected option settings, the PID     */
/*               is not supported.  In this case, a negative response      */
/*               code of 0x22 (condition not correct) will be sent         */
/*               instead of a PID response message.                        */
/*                                                                         */
/*               If "response_data_handler" is mentioned as APPL_HANDLE    */
/*               application should take care of checking all the possible */
/*               negative response and core will not handle it */
/*                                                                         */
/*      Example: End-item with 3 PIDs.  The first pid is created by        */
/*               calling "pid_1_function".  Pids 2 and 3 are fetched from  */
/*               "pid_2_buffer" (length=3 bytes) and "pid_3_buffer"        */
/*               (length=2 bytes) respectively.                            */
/*                Also PID 0x01 response is handled by Core and it is      */
/*                in 2 sessions. PIDs 0x02 and 0x03 responses are handled  */
/*                by application and it is supported in only one session   */
/*                                                                         */
/*               #define    PROD_SPEC_DIAG_PID_TABLE  \                    */
/*                {0x01, (void *) 0, 0, pid_1_function, CORE_HANDLE, (EXTENDEDSUBFUNC|SUPPLIERSUBFUNC)}, \ */
/*                {0x02, &pid_2_buffer,   3, (void *) 0, APPL_HANDLE, NO_SESSIONCHECK },                 \ */
/*                {0x03, &pid_3_buffer,   2, (void *) 0}, APPL_HANDLE, NO_SESSIONCHECK },                \ */
/*                                                                         */
/*               Functions in this list are executed only when the         */
/*               associated PID has been requested by a diagnostics        */
/*               message.                                                  */
/*                                                                         */
/* NOTE:         The following PIDS are universal and defined inside the   */
/*               kernel...DON'T configure here.                            */
/*               0xD100, 0x0200, 0x0202, 0xE200, 0xC900, 0xC901, 0xE6F2,   */
/*               0xE6F3                                                    */
/*                                                                         */
/* REQUIRED:     YES when mode 0x21 is supported through the configuration */
/*               of FNOS (however, the list can be NULL)                   */
/*                                                                         */
/* ACCESS:                                                                 */
/*                                                                         */
/*-------------------------------------------------------------------------*/
/* ======================================================================= */
/*                 BIT MAPPED PIDS                                         */
/* Kernel Controlled - None                                                */
/* ======================================================================= */
/*#define MODE_21_SUPPORTED*/

/* Note: If configured as APPL_HANDLE, then always configure function_ptr and handle
positive or negative response in the application */

/*
____DIAG_RLID_TABLE(){ }
*/
#define PROD_SPEC_DIAG_LID_TABLE                 \
/*	{GET_SYSTEM_IDENTIFICATION                  ,(void *) 0, 0, fdiag_app_80_get_system_identification, CORE_HANDLE, NO_SESSIONCHECK}		,\
	{GET_VEH_IDENT_NUM                          ,(void *) 0, 0, fdiag_app_81_get_Veh_iden_num, CORE_HANDLE, NO_SESSIONCHECK}		,\
*/
/*Sample*/ 

/*
___Service_3B_configuration(){ }
*/
/***************************************************************************/
/*              WriteDataByLocalIdentifier (0x3B) support.                      */
/***************************************************************************/
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DIAG_WRITE_LID_TABLE                            */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of entries for product     */
/*               specific EcuIdentification. Each entry must contain six   */
/*               items as follows:                                         */
/*                                                                         */
/*         {id, valid_modes, buffer_ptr, buffer_length, function_ptr,      */
/*          response_data_handler,supported_session}                       */
/*                                                                         */
/*               id         = 8-bit PID                                    */
/*               buffer_ptr  = pointer to a memory buffer of the PID...    */
/*                             USED ONLY IF "buffer_length" IS NON-ZERO.   */
/*               buffer_length = length of buffer pointed to by            */
/*                               "buffer_ptr" -OR- ZERO                    */
/*               function_ptr = pointer to function to call to fetch PID   */
/*                              bytes...USED ONLY IF "buffer_length" IS    */
/*                              ZERO.                                      */
/*              response_data_handler = whether response should be handled */
/*              by application or core (APPL_HANDLE or CORE_HANDLE)        */
/*              supported_session = sessions supported by LID              */
/*                                                                         */
/*               If "buffer_length" is non-zero, "buffer_ptr" will be      */
/*               used as a pointer to a memory buffer and "buffer_length"  */
/*               bytes will be fetched from the buffer and used to send a  */
/*               response message to the tester.                           */
/*                                                                         */
/*               If "buffer_length" is zero, the function pointed to by    */
/*               "function_ptr" is called to fetch the data.  The          */
/*               prototype for this function must be as follows:           */
/*                                                                         */
/*                 UCHAR function_name_KSGetPID(void *buffer);             */
/*                                                                         */
/*                 buffer - address of memory buffer where the called      */
/*                          function must place the pid data               */
/*                                                                         */
/*               The value returned by the function must be the number of  */
/*               bytes placed in the buffer (which represents the length   */
/*               of the PID).  The data length of the PID MUST NOT be      */
/*               greater than the (diag buffer length - 3).  The data      */
/*               the   function places in the buffer                       */
/*               is used to send a response message to the tester.  A      */
/*               return value of 0 may also be used to indicate that       */
/*               under the currently selected option settings, the PID     */
/*               is not supported.  In this case, a negative response      */
/*               code of 0x22 (condition not correct) will be sent         */
/*               instead of a PID response message.                        */
/*                                                                         */
/*               If "response_data_handler" is mentioned as APPL_HANDLE    */
/*               application should take care of checking all the possible */
/*               negative response and core will not handle it */
/*                                                                         */
/*      Example: End-item with 3 PIDs.  The first pid is created by        */
/*               calling "pid_1_function".  Pids 2 and 3 are fetched from  */
/*               "pid_2_buffer" (length=3 bytes) and "pid_3_buffer"        */
/*               (length=2 bytes) respectively.                            */
/*                Also PID 0x01 response is handled by Core and it is      */
/*                in 2 sessions. PIDs 0x02 and 0x03 responses are handled  */
/*                by application and it is supported in only one session   */
/*                                                                         */
/*               #define    PROD_SPEC_DIAG_PID_TABLE  \                    */
/*                {0x01, (void *) 0, 0, pid_1_function, CORE_HANDLE, (EXTENDEDSUBFUNC|SUPPLIERSUBFUNC)}, \ */
/*                {0x02, &pid_2_buffer,   3, (void *) 0, APPL_HANDLE, NO_SESSIONCHECK },                 \ */
/*                {0x03, &pid_3_buffer,   2, (void *) 0}, APPL_HANDLE, NO_SESSIONCHECK },                \ */
/*                                                                         */
/*               Functions in this list are executed only when the         */
/*               associated PID has been requested by a diagnostics        */
/*               message.                                                  */
/*                                                                         */
/* NOTE:         The following PIDS are universal and defined inside the   */
/*               kernel...DON'T configure here.                            */
/*               0xD100, 0x0200, 0x0202, 0xE200, 0xC900, 0xC901, 0xE6F2,   */
/*               0xE6F3                                                    */
/*                                                                         */
/* REQUIRED:     YES when mode 0x3B is supported through the configuration */
/*               of FNOS (however, the list can be NULL)                   */
/*                                                                         */
/* ACCESS:                                                                 */
/*                                                                         */
/*-------------------------------------------------------------------------*/
/*#define MODE_3B_SUPPORTED*/
/* Note: If configured as APPL_HANDLE, then always configure function_ptr and handle
positive or negative response in the application */

#define SET_VEH_IDENT_NUM						    ((UINT8) 0x81u)
#define SET_VEH_CONF_CAN_V							((UINT8) 0xB1u)

/*
____DIAG_WLID_TABLE(){ }
*/
#define PROD_SPEC_DIAG_WRITE_LID_TABLE                 \
/*	{SET_VEH_IDENT_NUM                   ,(void *) 0, 0x13, fdiag_app_81_set_veh_ident_num, APPL_HANDLE, (EXTENDEDSUBFUNC|SUPPLIERSUBFUNC)} ,\
	{SET_VEH_CONF_CAN_V                  ,(void *) 0, 0x04, fdiag_app_B1_set_veh_conf_can_v, CORE_HANDLE, (EXTENDEDSUBFUNC|SUPPLIERSUBFUNC)} ,\
*/

/*Sample*/ 


/*
___Service_22_configuration(){ }
*/

/***************************************************************************/
/*              ReadDataByIdentifier (0x22) support.                       */
/***************************************************************************/
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DIAG_PID_TABLE                                  */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of entries for product     */
/*               specific PIDs.  Each entry must contain five items as     */
/*               follows:                                                  */
/*                                                                         */
/*         {pid, valid_modes, buffer_ptr, buffer_length, function_ptr,     */
/*          supported_session}                                             */
/*                                                                         */
/*               pid         = 16-bit PID                                  */
/*               buffer_ptr  = pointer to a memory buffer of the PID...    */
/*                             USED ONLY IF "buffer_length" IS NON-ZERO.   */
/*               buffer_length = length of buffer pointed to by            */
/*                               "buffer_ptr" -OR- ZERO                    */
/*               function_ptr = pointer to function to call to fetch PID   */
/*                              bytes...USED ONLY IF "buffer_length" IS    */
/*                              ZERO.                                      */
/*              supported_session = sessions supported by LID              */
/*                                                                         */
/*               If "buffer_length" is non-zero, "buffer_ptr" will be      */
/*               used as a pointer to a memory buffer and "buffer_length"  */
/*               bytes will be fetched from the buffer and used to send a  */
/*               response message to the tester.                           */
/*                                                                         */
/*               If "buffer_length" is zero, the function pointed to by    */
/*               "function_ptr" is called to fetch the data.  The          */
/*               prototype for this function must be as follows:           */
/*                                                                         */
/*                 UCHAR function_name_KSGetPID(void *buffer);             */
/*                                                                         */
/*                 buffer - address of memory buffer where the called      */
/*                          function must place the pid data               */
/*                                                                         */
/*               The value returned by the function must be the number of  */
/*               bytes placed in the buffer (which represents the length   */
/*               of the PID).  The data length of the PID MUST NOT be      */
/*               greater than the (diag buffer length - 3).  The data      */
/*               the   function places in the buffer                       */
/*               is used to send a response message to the tester.  A      */
/*               return value of 0 may also be used to indicate that       */
/*               under the currently selected option settings, the PID     */
/*               is not supported.  In this case, a negative response      */
/*               code of 0x22 (condition not correct) will be sent         */
/*               instead of a PID response message.                        */
/*                                                                         */
/*      Example: End-item with 3 PIDs.  The first pid is created by        */
/*               calling "pid_1_function".  Pids 2 and 3 are fetched from  */
/*               "pid_2_buffer" (length=3 bytes) and "pid_3_buffer"        */
/*               (length=2 bytes) respectively.                            */
/*                                                                         */
/*               #define    PROD_SPEC_DIAG_PID_TABLE  \                    */
/*                {0x0001, (void *) 0, 0, pid_1_function, (EXTENDEDSUBFUNC|SUPPLIERSUBFUNC)}, \ */
/*                {0x0002, &pid_2_buffer,   3, (void *) 0, NO_SESSIONCHECK},                  \ */
/*                {0x0003, &pid_3_buffer,   2, (void *) 0, NO_SESSIONCHECK},                  \ */
/*                                                                         */
/*               Functions in this list are executed only when the         */
/*               associated PID has been requested by a diagnostics        */
/*               message.                                                  */
/*																		   */
/* NOTE:         The following PIDS are universal and defined inside the   */
/*               kernel...DON'T configure here.                            */
/*               0xD100, 0x0200, 0x0202, 0xE200, 0xC900, 0xC901, 0xE6F2,   */
/*               0xE6F3                                                    */
/*                                                                         */
/* REQUIRED:     YES when mode 0x22 is supported through the configuration */
/*               of FNOS (however, the list can be NULL)                   */
/*                                                                         */
/* ACCESS:                                                                 */
/*                                                                         */
/*-------------------------------------------------------------------------*/
/* ======================================================================= */
/*                 BIT MAPPED PIDS                                         */
/* Kernel Controlled - None                                                */
/* ======================================================================= */
#define MODE_22_SUPPORTED


/*
____DIAG_RPID_TABLE(){ }
*/
#define PROD_SPEC_DIAG_PID_TABLE                 \
	 {0x1701    ,(void *) 0, 0, fdiag_app_1701_get_motor_PosCnt           ,NO_SESSIONCHECK},\
	 {0x1702    ,(void *) 0, 0, fdiag_app_1702_get_motor_SoftPosCnt       ,NO_SESSIONCHECK},\
	 {0x170B    ,(void *) 0, 0, fdiag_app_170B_get_BAT_Voltage            ,NO_SESSIONCHECK},\
	 {0x1706    ,(void *) 0, 0, fdiag_app_1706_get_motor_learn_sts        ,NO_SESSIONCHECK},\
	 {0x1707    ,(void *) 0, 0, fdiag_app_1707_get_seat_motor_current     ,NO_SESSIONCHECK},\
	 {0x1708    ,(void *) 0, 0, fdiag_app_1708_get_key_sts        			 ,NO_SESSIONCHECK},\
	 {0x1709    ,(void *) 0, 0, fdiag_app_1709_get_motor_sts              ,NO_SESSIONCHECK},\
    {0xF183    ,(void *) 0, 0, fdiag_app_f183_get_boot_SW_version        ,NO_SESSIONCHECK},\
    {0xF186    ,(void *) 0, 0, fdiag_app_f186_get_current_session        ,NO_SESSIONCHECK},\
    {0xF187    ,(void *) 0, 0, fdiag_app_f187_get_OEM_Partnumber         ,NO_SESSIONCHECK},\
    {0xF188    ,(void *) 0, 0, fdiag_app_f188_get_Software_Number        ,NO_SESSIONCHECK},\
    {0xF189    ,(void *) 0, 0, fdiag_app_f189_get_SoftwareVersion        ,NO_SESSIONCHECK},\
    {0xF18A    ,(void *) 0, 0, fdiag_app_f18a_get_SupplyID               ,NO_SESSIONCHECK},\
    {0xF18B    ,(void *) 0, 0, fdiag_app_f18b_get_ecu_manufacture_date   ,NO_SESSIONCHECK},\
    {0xF18C    ,(void *) 0, 0, fdiag_app_f18c_get_serial_number   		 ,NO_SESSIONCHECK},\
    {0xF190    ,(void *) 0, 0, fdiag_app_f190_get_vin_data          		 ,NO_SESSIONCHECK},\
    {0xF191    ,(void *) 0, 0, fdiag_app_f191_get_hw_ver_number_data		 ,NO_SESSIONCHECK},\
    {0xF193    ,(void *) 0, 0, fdiag_app_f193_get_ecu_HW_number          ,NO_SESSIONCHECK},\
    {0xF195    ,(void *) 0, 0, fdiag_app_f195_get_ecu_SW_number          ,NO_SESSIONCHECK},\
    {0xF197    ,(void *) 0, 0, fdiag_app_f197_get_ECU_Name			       ,NO_SESSIONCHECK},\
    {0xF199    ,(void *) 0, 0, fdiag_app_f199_get_program_date			    ,NO_SESSIONCHECK},\
    {0xF19D    ,(void *) 0, 0, fdiag_app_f19d_get_vehicle_manu_date		 ,NO_SESSIONCHECK},\


/*
___Service_2E_configuration(){ }
*/

/***************************************************************************/
/*              WriteDataByIdentifier (0x2E) support.                      */
/***************************************************************************/
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DIAG_WRITE_PID_TABLE                            */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of entries for product     */
/*               specific PIDs.  Each entry must contain five items as     */
/*               follows:                                                  */
/*                                                                         */
/*         {pid, valid_modes, buffer_ptr, buffer_length, function_ptr,     */
/*          supported_session}                                             */
/*                                                                         */
/*               pid         = 16-bit PID                                  */
/*               buffer_length = length of buffer pointed to by            */
/*                               "buffer_ptr" -OR- ZERO                    */
/*               function_ptr = pointer to function to call to fetch PID   */
/*                              bytes...USED ONLY IF "buffer_length" IS    */
/*                              ZERO.                                      */
/*              supported_session = sessions supported by LID              */
/*                                                                         */
/*               If "buffer_length" is non-zero, "buffer_ptr" will be      */
/*               used as a pointer to a memory buffer and "buffer_length"  */
/*               bytes will be fetched from the buffer and used to send a  */
/*               response message to the tester.                           */
/*                                                                         */
/*               If "buffer_length" is zero, the function pointed to by    */
/*               "function_ptr" is called to fetch the data.  The          */
/*               prototype for this function must be as follows:           */
/*                                                                         */
/*                 UCHAR function_name_KSGetPID(void *buffer);             */
/*                                                                         */
/*                 buffer - address of memory buffer where the called      */
/*                          function must place the pid data               */
/*                                                                         */
/*               The value returned by the function must be 0 to indicate  */
/*               Positive response. In this case, a negative response      */
/*               error code (ex.0x22(condition not correct) need to be sent*/
/*               instead of a PID response message.                        */
/*                                                                         */
/*      Example: End-item with 3 PIDs.  The first pid is created by        */
/*               calling "pid_1_function".  Pids 2 and 3 are fetched from  */
/*               "pid_2_buffer" (length=3 bytes) and "pid_3_buffer"        */
/*               (length=2 bytes) respectively.                            */
/*                                                                         */
/*               #define    PROD_SPEC_DIAG_PID_TABLE  \                    */
/*                {0x0001, (void *) 0, 0, pid_1_function, (EXTENDEDSUBFUNC|SUPPLIERSUBFUNC)}, \ */
/*                {0x0002, &pid_2_buffer,   3, (void *) 0, NO_SESSIONCHECK},                  \ */
/*                {0x0003, &pid_3_buffer,   2, (void *) 0, NO_SESSIONCHECK},                  \ */
/*                                                                         */
/*               Functions in this list are executed only when the         */
/*               associated PID has been requested by a diagnostics        */
/*               message.                                                  */
/*                                                                         */
/*                                                                         */
/* REQUIRED:     YES when mode 0x2E is supported through the configuration */
/*               of FNOS (however, the list can be NULL)                   */
/*                                                                         */
/* ACCESS:                                                                 */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#define MODE_2E_SUPPORTED

#define SET_CFG_INFORMATION                 ((UINT16) 0x0100u)  


#define SET_CFG_INFORMATION_LENGTH         ((UINT8)  5u)



/*
____DIAG_WPID_TABLE(){ } 
*/
#define PROD_SPEC_DIAG_WRITE_PID_TABLE              \
    {SET_CFG_INFORMATION         ,(void *) 0,SET_CFG_INFORMATION_LENGTH,       fdiag_app_0100_set_cfg_information ,     NO_SESSIONCHECK},\
    
  
/*
___Service_2F_configuration(){ }
*/

#define MODE_2F_SUPPORTED
#ifdef KERNEL_PRIVATE_DIAG

#define RETURN_CONTROL_ECU                      ((DG_MGR_UINT8)0x00)
#define RESET_TO_DEFAULT                        ((DG_MGR_UINT8)0x01)
#define FREEZE_CURRENT_STATE                    ((DG_MGR_UINT8)0x02)
#define SHORT_TERM_ADJUST                       ((DG_MGR_UINT8)0x03)
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DIAG_IOCTL_BY_ID_TABLE                          */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro contains a table of entries for product        */
/*               specific I/O control parameters that can be accessed and  */
/*               modified by the tester via a mode 0x2F message.  Each     */
/*               entry in the table defines a different control parameter, */
/*               contains 7 fields and is formatted as follows:            */
/*                                                                         */
/*               {PID, action_mask,                                        */
/*                ctl_parm_buff_len, ctl_parm_buff_ptr, ctl_function_ptr,  */
/*                recover_function_ptr, valid_mode(s)}                     */
/*                                                                         */
/*               PID = 16 bit PID                                          */
/*               action_mask  = supported actions for the parameter        */
/*               ctl_parm_buff_len = number of control parameter bytes     */
/*               ctl_parm_buff_ptr = pointer to buffer where the control   */
/*                    parameter data bytes reside                          */
/*               ctl_function_ptr = pointer to function which is invoked   */
/*                    when the tester requests parameter modification      */
/*               recover_function_ptr = pointer to function which is       */
/*                    invoked when the control is timed out.               */
/*               valid_mode(s) = must be "ANY_DIAG" or "DM_ONLY".  Use     */
/*                             DM_ONLY if the id is to be processed        */
/*                             only in diagnostic mode (DM) or             */
/*                             ANY_DIAG if id is to be processed when      */
/*                             in any diagnostics mode.  When DM_ONLY      */
/*                             is used, a "conditions not correct"         */
/*                             response is sent when not in DM.            */
/*                                                                         */
/*               The "action_mask" field is formatted by bit wise ORing    */
/*               together actions supported for the parameter.  Valid      */
/*               actions are as follows (defined in "diagmain.h").         */
/*                                                                         */
/*                  RET_CTL     (return control to ECU)                    */
/*                  FRZ_STATE   (freeze current state)                     */
/*                  ST_ADJUST   (short term adjust)                        */
/*                                                                         */
/*               Example - parameter supports return control and short     */
/*               term adjust: (RET_CTL | ST_ADJUST).                       */
/*                                                                         */
/*               When the tester sends one I/O control request message     */
/*               the table is searched for the specified ID. If found, the */
/*               action mask is checked to see if the requested action is  */
/*               allowed...if not, a negative response message is sent     */
/*               back to tester.                                           */
/*                                                                         */
/*               When supported, the RET_CTL, FRZ_STATE, and LT_ADJUST     */
/*               requests are handled by calling the function pointed      */
/*               to by "ctl_function_ptr".  The function must match the    */
/*               following prototype:                                      */
/*                                                                         */
/*               UBYTE func_name_KSIOCtl(UBYTE control_action,             */
/*                                      UBYTE buffer_length,               */
/*                                      UBYTE *buffer_ptr);                */
/*                                                                         */
/*               where:                                                    */
/*                                                                         */
/*               control_action = action requested by tester (RET_CTL,     */
/*                  ST_ADJUST, LT_ADJUST, or RST_DEFAULT)                  */
/*               buffer_length  = number bytes pointed to by "buffer_ptr"  */
/*               buffer_ptr = pointer to data received from tester         */
/*                                                                         */
/*               After the function is called, the application processes   */
/*               the message.  When processing is complete, the function   */
/*               return the status of operation. Then, the diagnostic      */
/*               function will access the parameter data via the           */
/*               "ctl_parm_buff_ptr" .  Since the buffer must be available */
/*               for reading after the call time, RAM shadowing of         */
/*               EEPROM data may be necessary.                             */
/*                                                                         */
/*                                                                         */
/*               When a ST_AJUST or FRZ_STATE has been made for 5s without */
/*               any other diagnostic communication activities, the        */
/*               function pointed to by "recover_function_ptr" is called.  */
/*               The function pointer can be "NULL", or                    */
/*               The function must match the following prototype:          */
/*                                                                         */
/*               void func_name_KSAbortIOCtl(void);                        */
/*																		   */
/* NOTE:         1. Buffers referenced in this table must be available at  */
/*               all times.  If the object resides in EEPROM, then         */
/*               either an in-line write policy must be used on the        */
/*               product, or the table refers to a RAM shadow of the       */
/*               EEPROM contents (as when EPM-01 in DI-Kernel Bookshelf    */
/*               is used).                                                 */
/*               2. The 16-bit pid value should be typecasted with UWORD   */
/*               and suffixed u to avoid QAC warning.                      */
/*                                                                         */
/* REQUIRED:     YES when mode 0x2F is supported through the configuration */
/*               of FNOS (however, the list can be NULL)                   */
/*                                                                         */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
/*
____DIAG_IOCTL_PID_TABLE(){ }
*/


#define Control_WPC                ((UINT16) 0x3700) 
#define Control_BT                 ((UINT16) 0x3701) 

/*Sample*/
#define PROD_SPEC_DIAG_IOCTL_BY_ID_TABLE            \
{  Control_WPC               ,RETURN_CONTROL_ECU|SHORT_TERM_ADJUST, \
   IOCTL_WPC_SIZE    ,&IOCTL_WPC_buffer[0], dg_app_3700_KSIOCTL, dg_app_3700_KSAbortIOCTL, ANY_DIAG}, \
{  Control_BT               ,RETURN_CONTROL_ECU|SHORT_TERM_ADJUST, \
   IOCTL_BT_SIZE    ,&IOCTL_BT_buffer[0], dg_app_3701_KSIOCTL, dg_app_3701_KSAbortIOCTL, ANY_DIAG}, \


#endif /* KERNEL_PRIVATE_DIAG */
/*
___Service_30_configuration(){ }
*/

//#define MODE_30_SUPPORTED

#ifdef KERNEL_PRIVATE_DIAG

#define LID_RETURN_CONTROL_ECU                      ((DG_MGR_UINT8)0x00) /*Hyundai_DM_DATC Specific -> Stop Control*/

/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DIAG_IOCTL_BY_LID_TABLE                          */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro contains a table of entries for product        */
/*               specific I/O control parameters that can be accessed and  */
/*               modified by the tester via a mode 0x30 message.  Each     */
/*               entry in the table defines a different control parameter, */
/*               contains 7 fields and is formatted as follows:            */
/*                                                                         */
/*               {LID, valid_modes, action_mask,                           */
/*                ctl_parm_buff_len, ctl_parm_buff_ptr, ctl_function_ptr,  */
/*                recover_function_ptr}                                    */
/*                                                                         */
/*               LID = 8 bit LID                                           */
/*               valid_mode(s) = must be "ANY_DIAG" or "DM_ONLY".  Use     */
/*                             DM_ONLY if the id is to be processed        */
/*                             only in diagnostic mode (DM) or             */
/*                             ANY_DIAG if id is to be processed when      */
/*                             in any diagnostics mode.  When DM_ONLY      */
/*                             is used, a "conditions not correct"         */
/*                             response is sent when not in DM.            */
/*               action_mask  = supported actions for the parameter        */
/*               ctl_parm_buff_len = number of control parameter bytes     */
/*               ctl_parm_buff_ptr = pointer to buffer where the control   */
/*                    parameter data bytes reside                          */
/*               ctl_function_ptr = pointer to function which is invoked   */
/*                    when the tester requests parameter modification      */
/*               recover_function_ptr = pointer to function which is       */
/*                    invoked when the control is timed out.               */
/*                                                                         */
/*               The "action_mask" field is formatted by bit wise ORing    */
/*               together actions supported for the parameter.  Valid      */
/*               actions are as follows (defined in "diagmain.h").         */
/*                                                                         */
/*                  RET_CTL     (return control to ECU)                    */
/*                  FRZ_STATE   (freeze current state)                     */
/*                  ST_ADJUST   (short term adjust)                        */
/*                                                                         */
/*               Example - parameter supports return control and short     */
/*               term adjust: (RET_CTL | ST_ADJUST).                       */
/*                                                                         */
/*               When the tester sends one I/O control request message     */
/*               the table is searched for the specified ID. If found, the */
/*               action mask is checked to see if the requested action is  */
/*               allowed...if not, a negative response message is sent     */
/*               back to tester.                                           */
/*                                                                         */
/*               When supported, the RET_CTL, FRZ_STATE, and LT_ADJUST     */
/*               requests are handled by calling the function pointed      */
/*               to by "ctl_function_ptr".  The function must match the    */
/*               following prototype:                                      */
/*                                                                         */
/*               UBYTE func_name_KSIOCtl(UBYTE control_action,             */
/*                                      UBYTE buffer_length,               */
/*                                      UBYTE *buffer_ptr);                */
/*                                                                         */
/*               where:                                                    */
/*                                                                         */
/*               control_action = action requested by tester (RET_CTL,     */
/*                  ST_ADJUST, LT_ADJUST, or RST_DEFAULT)                  */
/*               buffer_length  = number bytes pointed to by "buffer_ptr"  */
/*               buffer_ptr = pointer to data received from tester         */
/*                                                                         */
/*               After the function is called, the application processes   */
/*               the message.  When processing is complete, the function   */
/*               return the status of operation. Then, the diagnostic      */
/*               function will access the parameter data via the           */
/*               "ctl_parm_buff_ptr" .  Since the buffer must be available */
/*               for reading after the call time, RAM shadowing of         */
/*               EEPROM data may be necessary.                             */
/*                                                                         */
/*                                                                         */
/*               When a ST_AJUST or FRZ_STATE has been made for 5s without */
/*               any other diagnostic communication activities, the        */
/*               function pointed to by "recover_function_ptr" is called.  */
/*               The function pointer can be "NULL", or                    */
/*               The function must match the following prototype:          */
/*                                                                         */
/*               void func_name_KSAbortIOCtl(void);                        */
/*                                                                         */
/* NOTE:         1. Buffers referenced in this table must be available at  */
/*               all times.  If the object resides in EEPROM, then         */
/*               either an in-line write policy must be used on the        */
/*               product, or the table refers to a RAM shadow of the       */
/*               EEPROM contents (as when EPM-01 in DI-Kernel Bookshelf    */
/*               is used).                                                 */
/*               2. The 16-bit pid value should be typecasted with UWORD   */
/*               and suffixed u to avoid QAC warning.                      */
/*                                                                         */
/* REQUIRED:     YES when mode 0x2F is supported through the configuration */
/*               of FNOS (however, the list can be NULL)                   */
/*                                                                         */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
/*
____DIAG_IOCTL_LID_TABLE(){ }
*/
#define PROD_SPEC_DIAG_IOCTL_BY_LID_TABLE           \
/*{   0x01,0,sizeof(l_tt_ctrl_status_U8),&l_tt_ctrl_status_U8,fdiag_io_tt_ctrl, NULL, DG_EXTENDED},\
{   0x02,0,sizeof(l_buzzer_ctrl_status_U8),&l_buzzer_ctrl_status_U8,fdiag_io_buzzer_ctrl, NULL, DG_EXTENDED},\
{   0x03,0,sizeof(l_disp_ctrl_status_U8),&l_disp_ctrl_status_U8,fdiag_io_disp_ctrl, NULL, DG_EXTENDED},\
{   0x04,0,sizeof(l_gauge_ctrl_status_U8),&l_gauge_ctrl_status_U8,fdiag_io_gauge_ctrl, NULL, DG_EXTENDED},\
{   0x05,0,sizeof(l_illum_ctrl_status_U8),&l_illum_ctrl_status_U8,fdiag_io_illum_ctrl, NULL, DG_EXTENDED},\
*/
#endif  /* KERNEL_PRIVATE_DIAG */

/*
___Service_23_configuration(){ }
*/
/*-------------------------------------------------------------------------*/
/*#define MODE_23_SUPPORTED */

#ifdef MODE_23_SUPPORTED
    /* Define the following macro with either of the following values 
    ISO_14229_BASED
    KWP_BASED
    APPL_SPECIFIC
    */
#define MODE_23_SUPPORTED_BASED_ON KWP_BASED

	#if (MODE_23_SUPPORTED_BASED_ON == APPL_SPECIFIC)
	/* If this condition is true, application needs to take care of sending both positive/negative response */
	    #define Prod_Spec_Read_Memory_Address_Handler( bufptr, dataLen) \
				Read_Memory_Address_Handler( (void *)bufptr, dataLen)

	#endif

	#if (MODE_23_SUPPORTED_BASED_ON != APPL_SPECIFIC)
	/* Apllication needs to take care of sending positive response */
	    #define Prod_Spec_Read_Memory_Address(fl_dmr_addr_U32, fl_dmr_size_U16, buffer) \
				app_spec_read_memory_address(fl_dmr_addr_U32, fl_dmr_size_U16, (void *)buffer)

	#endif /* MODE_23_SUPPORTED_BASED_ON */

#define  DMR_MAXIMUM_ADDRESS_READ      (ULONG)0xFF0000 
#define  PROD_SPEC_DIAG_DMR_PROTECT_RANGES     \
           {0x0000, 0x0000},   \

#endif  /* mode 23 supported */

/*
___Service_3D_configuration(){ }
*/
/*-------------------------------------------------------------------------*/
/* #define MODE_3D_SUPPORTED */

/* Mode 3D related macro definitions */
#ifdef MODE_3D_SUPPORTED

/* Define this macro with either of the following 3 values -> APPL_SPECIFIC or KWP_BASED or ISO_14229_BASED */
#define MODE_3D_SUPPORTED_BASED_ON ISO_14229_BASED

#if (MODE_3D_SUPPORTED_BASED_ON == APPL_SPECIFIC)
/* If this condition is true, application needs to take care of sending both positive/negative response */
#define Prod_Spec_Write_Memory_Address_Handler( bufptr, dataLen)\
		fdiag_Write_Memory_Address_Handler(bufptr, dataLen)

#else
/* Apllication needs to take care of sending positive response */
	#define Prod_Spec_Write_Memory_Address(fl_dmw_addr_U32, fl_dmr_size_U16, bufptr) \


#endif /* MODE_3D_SUPPORTED_BASED_ON */

#define  DMR_MAXIMUM_ADDRESS_WRITE      (ULONG)0xFF0000 
#define  PROD_SPEC_DIAG_DMW_PROTECT_RANGES\
           {(void*)0x0000, (void *) 0x0000},   \

#endif /* MODE_3D_SUPPORTED */

/*
___Service_31_32_33_configuration(){ }
*/

/***************************************************************************/
/*              Routine Control supported for following IDs.               */
/***************************************************************************/
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DIAG_ROUTINE_CONTROL                            */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of entries for product     */
/*               specific routine control. Each entry must contain four    */
/*               items as follows:                                         */
/*                                                                         */
/*         {Routine_ID, Supported_Routine,valid_sessions, function_ptr}    */
/*                                                                         */
/*           Routine_ID        = 16-bit Routine ID                         */
/*           data length       =                                           */
/*           Supported_Routine = Routine type( start,stop, request result) */
/*           function_ptr      = pointer to function to call the           */
/*                               corresponding                             */
/*                                                                         */
/*             #define    PROD_SPEC_DIAG_ROUTINE_CONTROL  \                */
/*              {0x0001, 1, RC_ALL, routine_id_1_function}, \  */
/*              {0x0002, 2, START, routine_id_1_function},     \     */
/*                                                                         */
/*-------------------------------------------------------------------------*/

#define MODE_31_SUPPORTED
//#define MODE_32_SUPPORTED
//#define MODE_33_SUPPORTED

#define ASYNC       0x00
#define SYNC        0x01
#define RC_START          (UINT8)0x01u
#define RC_STOP           (UINT8)0x02u
#define RC_REQ_RESULT     (UINT8)0x04u
#define RC_ALL            (RC_START|RC_STOP|RC_REQ_RESULT)

#define PROD_SPEC_NO_SUPP_RC          ((UINT8)0x03u)    /* whenever a routine is added this count shall be increased by 1 */

#define DIAG_CHK_ROUTINE_PRG_CON			    (0x0203)

/*
____DIAG_ROUTINE_CTL_TABLE(){ }
*/
#define PROD_SPEC_DIAG_ROUTINE_CONTROL \
      {0x0203,2, RC_START|RC_STOP, ASYNC, fdiag_app_0203_Routine_Control},\
		{0xFF00,2, RC_START|RC_STOP, ASYNC, fdiag_app_FF00_Routine_Control},\
		{0x0202,2, RC_START|RC_STOP, ASYNC, fdiag_app_0202_Routine_Control},\
		{0xFF01,2, RC_START|RC_STOP, ASYNC, fdiag_app_FF01_Routine_Control},\
		{0xF518,2, RC_START|RC_STOP, ASYNC, fdiag_app_F518_Routine_Control},\
		{0xDF01,2, RC_START|RC_STOP, ASYNC, fdiag_app_DF01_Routine_Control},\


/*---------------------------------------------------------------------------------**
** **--------------------------------------------------------------------------**  **
** ** UINT8 dg_app_01_ecu_selftest(UINT8 * const bufptr, UINT8 p_reqtype_U8) **    **
** ** {                                                                        **  **
** **   UINT8 fl_return_U8;                                                    **  **
** **   UINT8 fl_get_diagnostics_session_U8;                                   **  **
** **                                                                          **  **
** **   fl_get_diagnostics_session_U8 = get_diagnostics_session();             **  **
** **                                                                          **  **
** **   if(fl_get_diagnostics_session_U8 == DIAG_EXTENDED_SESSION)             **  **
** **   {                                                                      **  **
** **     ** start command **                                                  **  **
** **     if( ROUTINE_START == p_reqtype_U8 )                                  **  **
** **     {                                                                    **  **
** 			**RoutineEntryOption:**                                                **
** 			**= $00 Perform routine requested**                                    **
** 			**= $01 Status Request**                                               **
**                                                                                 **
** 		 if(bufptr[0] == 0x00)                                                     **
** 		 {                                                                         **
** **	       fl_return_U8 = dg_app_ecu_selftest_start(bufptr);                ** **
** 		 }                                                                         **
** 		 else if (bufptr[0] == 0x01)                                               **
** 		 {                                                                         **
** **       fl_return_U8 = dg_app_ecu_selftest_status_request(bufptr);         **  **
** 		 }                                                                         **
** 		 else                                                                      **
** 		 {                                                                         **
** **  	   bufptr[0] = REQUEST_OUT_OF_RANGE;                                **     **
** **	       fl_return_U8 = ERROR_IN_REQUEST;                                 ** **
** 		 }                                                                         **
**                                                                                 **
** **     }                                                                    **  **
** **     ** stop command **                                                   **  **
** **     else if( ROUTINE_STOP == p_reqtype_U8 )                              **  **
** **     {                                                                    **  **
** **       bufptr[0] = SUBFN_NOT_SUPPORTED;                                   **  **
** **       fl_return_U8 = ERROR_IN_REQUEST;                                   **  **
** **     }                                                                    **  **
** **     ** request result command **                                         **  **
** **     else if( ROUTINE_RESULT == p_reqtype_U8 )                            **  **
** **     {                                                                    **  **
** **       fl_return_U8 = dg_app_ecu_selftest_result(bufptr);                 **  **
** **     }                                                                    **  **
** **     else                                                                 **  **
** **     {                                                                    **  **
** **       bufptr[0] = REQUEST_OUT_OF_RANGE;                                  **  **
** **       fl_return_U8 = ERROR_IN_REQUEST;                                   **  **
** **     }                                                                    **  **
** **                                                                          **  **
** **   }                                                                      **  **
** **   else                                                                   **  **
** **   {                                                                      **  **
** **     bufptr[0] = kDescNrcServiceNotSupportedInActiveSession;              **  **
** **     fl_return_U8 = ERROR_IN_REQUEST;                                     **  **
** **   }                                                                      **  **
** **   return fl_return_U8;                                                   **  **
** ** }                                                                        **  **
** **--------------------------------------------------------------------------*  **
**                                                                                 **
**                                                                                 **
**---------------------------------------------------------------------------------*/


/*
___Selftest_configuration(){ }
*/


/*#define PROD_SPEC_SELF_TEST_SUPPORTED */

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_DENY_SELF_TEST_LIST                             */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of all functions that are  */
/*               to be executed BEFORE entering self test. Any tasks that  */
/*               have conditions which can prevent self test state from    */
/*               being entered must register (place) a function here.      */
/*               Functions in this list must match the following prototype:*/
/*                                                                         */
/*                 BOOLEAN function_name_KSDenySelfTest(void);             */
/*                                                                         */
/*               The values returned by functions in this list must be as  */
/*               follows:                                                  */
/*                                                                         */
/*                 TRUE if self test CANNOT be entered.                    */
/*                 FALSE if OK to enter self test state.                   */
/*                                                                         */
/*               If any function in the list returns TRUE, self test       */
/*               state will NOT be entered (response message indicating    */
/*               "conditions not correct" will be sent to the tester).     */
/*                                                                         */
/*               Functions in this list are executed sequentially from the */
/*               first function in the list until the last.                */
/*                                                                         */
/* NOTE:         Functions in this list should return very quickly         */
/*               (maximum execution time much less than 1 millisecond).    */
/*                                                                         */
/* REQUIRED:     YES (however, the list can be NULL)                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#define  PROD_SPEC_DENY_SELF_TEST_LIST  \


#endif  /* KERNEL_PRIVATE_DIAG */


#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_START_SELF_TEST_LIST                            */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of all functions that are  */
/*               to be executed upon entry into diagnostics self test.     */
/*               Functions in this list must match the following           */
/*               prototype:                                                */
/*                                                                         */
/*                 void function_name_KSDiagStartSelfTest(void);           */
/*                                                                         */
/*               Functions in this list are executed sequentially from the */
/*               first function in the list until the last.                */
/*                                                                         */
/* NOTE:         Self-test operations (e.g. turn on telltale) can be       */
/*               performed within these functions, but the functions       */
/*               should return as quickly as possible (maximum             */
/*               execution time of 1 millisecond per function).            */
/*                                                                         */
/*               Self-test operations which can complete in one function   */
/*               call (e.g. module configuration check) will NOT have      */
/*               a corresponding function in either the                    */
/*               PROD_SPEC_SELF_TEST_LIST or the                           */
/*               PROD_SPEC_TERMINATE_SELF_TEST_LIST.                       */
/*                                                                         */
/* REQUIRED:     YES (however, the list can be NULL)                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#define  PROD_SPEC_START_SELF_TEST_LIST   \


#endif  /* KERNEL_PRIVATE_DIAG */


#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_SELF_TEST_LIST                                  */
/*               PROD_SPEC_SELF_TEST_TIMER_BASE                            */
/*               PROD_SPEC_SELF_TEST_TIMER_TIME                            */
/*                                                                         */
/* TYPE:         MACRO's                                                   */
/*                                                                         */
/* DESCRIPTION:  The PROD_SPEC_SELF_TEST_LIST macro must contain a list of */
/*               all functions that are to be executed during diagnostics  */
/*               self test.  Functions in this list must match the         */
/*               following prototype:                                      */
/*                                                                         */
/*               BOOLEAN function_name_KSDiagSelfTest(                     */
/*                                      BOOLEAN  selftest_timer_expired);  */
/*                                                                         */
/*               The value of the selftest_timer_expired parameter will    */
/*               be as follows:                                            */
/*                                                                         */
/*                 TRUE if the time specified by the                       */
/*                      PROD_SPEC_SELF_TEST_TIMER_BASE times               */
/*                      PROD_SPEC_SELF_TEST_TIMER_TIME has elapsed since   */
/*                      the beginning of self test.                        */
/*                      in PROD_SPEC_SELF_TEST_TIME                        */
/*                 FALSE if the time specified by the                      */
/*                      PROD_SPEC_SELF_TEST_TIMER_BASE times               */
/*                      PROD_SPEC_SELF_TEST_TIMER_TIME has NOT elapsed     */
/*                      since the beginning of self test.                  */
/*                                                                         */
/*               The values returned by functions in this list must be as  */
/*               follows:                                                  */
/*                                                                         */
/*                 TRUE if self test functionality done by the function is */
/*                      complete                                           */
/*                 FALSE if still performing self test functionality       */
/*                                                                         */
/*               The kernel will not conMODEer self test to be completed    */
/*               until all functions in the list return TRUE.              */
/*                                                                         */
/*               Functions in this list are executed sequentially from the */
/*               first function in the list until the last.                */
/*                                                                         */
/*               The PROD_SPEC_SELF_TEST_TIMER_BASE must specify a valid   */
/*               software timer time base (as specified in swtmr.h) and    */
/*               PROD_SPEC_SELF_TEST_TIMER_TIME must be in 1..127.         */
/*               These two macros together specify the self test timer.    */
/*                                                                         */
/* NOTE:         1. Functions in this list should return very quickly      */
/*               (maximum execution time much less than 1 millisecond).    */
/*               2. PROD_SPEC_SELF_TEST_TIMER_TIME should be typecasted    */
/*               with UWORD and suffixed u to avoid QAC warning.           */
/*                                                                         */
/*                                                                         */
/* REQUIRED:     YES (however, the list can be NULL)                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
/*#define  PROD_SPEC_SELF_TEST_TIMER_BASE    
#define  PROD_SPEC_SELF_TEST_TIMER_TIME    
*/


#define  PROD_SPEC_SELF_TEST_LIST   \


#endif  /* KERNEL_PRIVATE_DIAG */

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_TERMINATE_SELF_TEST_LIST                        */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of all functions that      */
/*               need to be called when self test is terminated/completed. */
/*                                                                         */
/*               The functions in this list are required to restore        */
/*               pertinent state information, hardware, etc. to the state  */
/*               it was in prior to starting self test.  Functions in this */
/*               list must match the following prototype:                  */
/*                                                                         */
/*                 void function_name_KSTermSelfTest(void);                */
/*                                                                         */
/*               Functions in this list are executed sequentially from the */
/*               first function in the list until the last.                */
/*                                                                         */
/* NOTE:         Functions in this list should return very quickly         */
/*               (maximum execution time much less than 1 millisecond).    */
/*                                                                         */
/* REQUIRED:     YES (however, the list can be NULL)                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/

#define PROD_SPEC_TERMINATE_SELF_TEST_LIST  \

#endif  /* KERNEL_PRIVATE_DIAG */


#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_ABORT_SELF_TEST_LIST                            */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro must contain a list of all functions that are  */
/*               called during self test mode which can abort self test    */
/*               mode.  Functions in this list must match the following    */
/*               prototype:                                                */
/*                                                                         */
/*                 BOOLEAN function_name_KSAbortSelfTest(void);            */
/*                                                                         */
/*               The values returned by functions in this list must be as  */
/*               follows:                                                  */
/*                                                                         */
/*                 TRUE if self test mode should be aborted.               */
/*                 FALSE if OK to remain in self test.                     */
/*                                                                         */
/*               If any function in the list returns TRUE, self test will  */
/*               be aborted immediately.                                   */
/*                                                                         */
/*               Functions in this list are executed sequentially from the */
/*               first function in the list until the last.                */
/*                                                                         */
/* NOTE:         Functions in this list should return very quickly         */
/*               (maximum execution time much less than 1 millisecond).    */
/*                                                                         */
/* REQUIRED:     YES (however, the list can be NULL)                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/

#define  PROD_SPEC_ABORT_SELF_TEST_LIST \


#endif  /* KERNEL_PRIVATE_DIAG */
/*
___Diagnostics_Core_Manager_Configuration(){ }
*/

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_PERIODIC_DIAG_RATE                              */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  The diagnostics manager of GGDS diagnostics subsystem     */
/*               must be run on a periodic basis instead of at the end     */
/*               of each context sensitive loop.                           */
/*               Periodic diagnostic processing is selected at a default   */
/*               rate of 40 milliseconds.  If a rate other than 40         */
/*               milliseconds is desired, the PROD_SPEC_PERIODIC_DIAG_RATE */
/*               symbol must be defined with the periodic rate to use.     */
/*               When defined, the PROD_SPEC_PERIODIC_DIAG_RATE parameter  */
/*               specifies the periodic rate in terms of the number of 4   */
/*               millisecond intervals between each scheduling of the      */
/*               diagnostic manager (a value of 8 selects a periodic rate  */
/*               of 32 milliseconds).  PROD_SPEC_PERIODIC_DIAG_RATE must   */
/*               be between 2..10 (inclusive), thus the periodic rate is   */
/*               configurable from 8..40 milliseconds (inclusive).         */
/* NOTE:         The rate must be the same as the FNOS diagnostic task     */
/*               schdule rate: kDescCallCycleUs in the FNOS genaration     */
/*               tool).                                                    */
/*               The unit of kDescCallCycleUs is  microsecond,             */
/*               so the kDescCallCycleUs has to be multiple                */
/*               times of 4000. The following equation has to be fulfilled:*/
/*                                                                         */
/*               PROD_SPEC_PERIODIC_DIAG_RATE = (kDescCallCycleUs) / 4000. */
/*                                                                         */
/*                                                                         */
/* REQUIRED:     Yes.                                                      */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/

#define PROD_SPEC_PERIODIC_DIAG_RATE        2   /* period = 8 ms */

#endif /* KERNEL_PRIVATE_DIAG */

/*
___Rand_Generator_configuration(){ }
*/

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_SEC_ACC_RAND_GENERATOR                          */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro is used to specify the random number generator */
/*               for calculating the seed value and key value              */
/*               Typically this could be the free running timer            */
/*                                                                         */
/* REQUIRED:     YES.                                                      */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#define PROD_SPEC_SEC_ACC_RAND_GENERATOR   R_TCNT

#endif /* KERNEL_PRIVATE_DIAG */

/*
___FSM__Configuration(){ }
*/
#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_FSM_CONFIGURE     		                       */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:															  */
/*             															  */
/*             															  */
/*             															  */
/* NOTE:       															  */
/*             															  */
/*             															  */
/*                                                                         */
/* REQUIRED:     Yes.                                                      */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/

/* #define PROD_SPEC_FSM_CONFIGURE */

#ifdef 	PROD_SPEC_FSM_CONFIGURE

#define KWP2K_DIAG_FSM_GET_SUPER_STATE 	FSM_get_SuperState_U8
#define KWP2K_DIAG_FSM_SET_ISUPER_STATE FSM_Set_Immediate_SuperState

/*#define DIAGNOSTIC_MODE         (0x40)*/

/* INITIALIZE context is highest priority */
/*
#define	INPUT_DEBOUNCE          (0x80)
#define LVI_HVI_MODE            (0x40)
#define KEY_OFF_MODE            (0x20)
#define STANDBY_MODE            (0x08)
#define CHAMBER_MODE            (0x04)
#define	NORMAL_MODE             (0x01)
*/

#endif

#endif /* KERNEL_PRIVATE_DIAG */


/*
___NW_Session_Macro_map(){ }
*/
#define kwp2k_diag_session_default		0x01 /*KWPDIAG_DEFAULTSESS_ID*/
#define kwp2k_diag_session_programming  0x02 /*KWPDIAG_PROGSESS_ID*/
#define kwp2k_diag_session_extended     0x03 /*KWPDIAG_EXTENDEDSESS_ID*/  
#define kwp2k_diag_session_supplier     0xFA /*KWPDIAG_SUPPLIER_ID*/  


/*----------------------------------------------------------**
** Network Interface to send positive and negative response **
**----------------------------------------------------------*/
/*
___NW_Response_Interface_map(){ }
*/
#define	KWP2K_DIAG_SEND_NO_RESPONSE(pRespBuf, length)	 					vnim_tx_diag_response (VNTD_NO_RESPONSE_MSGID , (void *)(pRespBuf), (length), 0)
#define VNTD_RING_BUFFER_DATA_FILL_MSGID FALSE;
#define	KWP2K_DIAG_SEND_IMMEDIATE_RESPONSE(pRespBuf, length)	 			vnim_tx_diag_response (VNTD_POS_RESPONSE_MSGID , (void *)(pRespBuf), (length), 0)
#define	KWP2K_DIAG_SEND_ERROR_RESPONSE(pRespBuf)  							vnim_tx_diag_response (VNTD_ERROR_RESPONSE_MSGID, (void *)(pRespBuf), 1, 0)
#define	KWP2K_DIAG_SEND_SESSION_TRANSITION_RESPONSE(pRespBuf, length)	 	vnim_tx_diag_response (VNTD_POS_RESPONSE_MSGID , (void *)(pRespBuf), (length), 0)
#define	KWP2K_DIAG_INSPECT_DIAG_RESPONSE_REQUIRED()							FALSE /* vnim_rx_diag_info_inspect */
//#define KWP2K_DIAG_SEND_RING_BUFFER_START(pRespBuf,length, tot_len)         vnim_tx_diag_response (VNTD_INITIAL_RING_BUFFER_RESPONSE_MSGID, (void *)(pRespBuf), (length), tot_len)
//#define	KWP2K_DIAG_SEND_RING_BUFFER_DATA(pRespBuf,length)  					vnim_tx_diag_response (VNTD_RING_BUFFER_DATA_FILL_MSGID, (void *)(pRespBuf), (length), 0)

//#define	KWP2K_DIAG_SEND_RING_INITIAL_BUFFER(pRespBuf, length, totalLength)  vnim_tx_diag_response (VNTD_INITIAL_RING_BUFFER_RESPONSE_MSGID, (void *)(pRespBuf), (length), (totalLength))

#define KWP2K_DIAG_SUPPRESS_RESPONSE() 			kwpdiag_postprocessing(kwpdiag_currreq,VTP_SUCCESS)

/*----------------------------------**
** DI Kernal error report interface **
**----------------------------------*/
/*
___DI_Kernal_Error_Report_Interface_map(){ }
*/
								
#define	KWP2K_DIAG_RAM_ERROR	RAM_ERROR
#define	KWP2K_DIAG_REPORT_ERROR(error_code)	KernelReportError(error_code)
#define	KWP2K_DIAG_MEMCPY(destination, source, length)	memcpy(destination, source, length)
#define	KWP2K_DIAG_MEMSET(destination, data, length)	memset(destination, data, length)

/*
___Kernal_Timer_Configuration(){ }
*/
#define	KWP2K_DIAG_CLEAR_TIMER(timer_id) 					    KernelClear13BitTimer(timer_id)
#define KWP2K_DIAG_START_TIMER(timer_base, timeout, timer_id) 	KernelStart13BitTimer(timer_base, timeout, timer_id)
#define	KWP2K_DIAG_CHECK_TIMER(timer_id)						KernelCheck13BitTimer(timer_id)
#define KWP2K_DIAG_TIMER_BASE TIMER_13BIT_BASE_4MS

#ifdef MODE_11_ECU_RESETRESP_TIMER_SUPPORTED
#define	KWP2K_DIAG_ECU_RESET_TIMER 		diag_ecureset_KSWTIMER
#endif

#ifdef MODE_10_SUBFUNC_02_SUPPORTED
#define KWP2K_DIAG_PROG_SESSION_TIMER 	kwp2k_core_prog_session_KSWTIMER
#endif

#ifdef KERNEL_PRIVATE_DIAG
/*-------------------------------------------------------------------------*/
/*                                                                         */
/* NAME:         PROD_SPEC_ECURESET_TIMEOUT                                */
/*                                                                         */
/* TYPE:         MACRO                                                     */
/*                                                                         */
/* DESCRIPTION:  This macro specifies the timeout time for the abandoning  */
/*               the ECU Reset request when the positive response is       */
/*               message could not be send .                               */
/*                                                                         */
/*               This timer is implemented using Kernel TIMER with 4Msec   */
/*               as the timer Base.When the ECU RESET command is received  */
/*               the timer is started and a positive response is qued.     */
/*               In the main loop the diag manager will check if the       */
/*               callback is fired.The waiting time for the callback       */
/*               function is implemented using this timer. If the timer    */
/*               expires before the callback confirming the positive       */
/*               response sent, then the reset operation is aborted.       */
/*                                                                         */
/*                                                                         */
/*               Typical value is 500Msec.                                 */
/*                                                                         */
/* REQUIRED:     Yes                                                       */
/*                                                                         */
/* ACCESS:       KERNEL_PRIVATE_DIAG                                       */
/*                                                                         */
/*-------------------------------------------------------------------------*/
#define PROD_SPEC_ECURESET_TIMEOUT  ((UINT16)40) /* 120*0.004 = 0.5Sec */

#endif /* KERNEL_PRIVATE_DIAG */

/*-------------------------------------**
** Configure Core component Interface  **
** to App specific N/W interfaces      **
**-------------------------------------*/
/*
______________Network_Interface_functions(){ }
*/

							  
/*
___Service_10_application_interface_map(){ }
*/

#define kwp2k_core_Diag_CheckSessionTransition		ApplDiagStartDiagnosticSession
#define kwp2k_core_Diag_OnTransitionSession         ApplDiagStartDiagnosticSessionPosthandler

/*
___Service_11_application_interface_map(){ }
*/

#define kwp2k_core_Diag_ECU_reset				ApplDiagEcuReset			
#define kwp2k_core_Diag_ecu_resp_confirmed		ApplDiagEcuResetPosthandler

//#ifdef ERROR_HANDLER_SUPPORTED
/*
___Service_14_uds_application_interface_map(){ }
*/
/* Define either one of the below macro */
/* #define kwp2k_core_Diag_ClearDTCs_UDS				ApplDiagClearDiagnosticInformation */
//#ifdef MODE_14_UDS_SUPPORTED
#define kwp2k_core_Diag_ClearDTCs_UDS				ApplDiagClearDiagnosticInformation
//#endif

/*
___Service_17_application_interface_map(){ }
*/
/*#define kwp2k_core_Diag_read_status_of_dtc 			ApplDiagReadDTCByStatus*/

/*
___Service_18_application_interface_map(){ }
*/
#define kwp2k_core_Diag_read_dtc_by_status     ApplDiagReadDTCByStatus

/*
___Service_19_application_interface_map(){ }
*/
#define kwp2k_core_Diag_read_dtc_info			ApplDiagReadDTCInformation

//#endif /* ERROR_HANDLER_SUPPORTED */

/*
___Service_21_application_interface_map(){ }
*/
#define kwp2k_core_Diag_read_data_by_lid_msgid		ApplDiagReadDataByLocalId

/*
___Service_1A_application_interface_map(){ }
*/
#define kwp2k_core_Diag_read_ecu_identification_msgid		ApplDiagReadECUIdentification
/*
___Service_3B_application_interface_map(){ }
*/
#define kwp2k_core_Diag_write_data_by_lid_msgid		ApplDiagWriteDataByLocalIdentifier			

#define kwp2k_core_DiagWriteDataByLocalIdentifierPosthandler  ApplDiagWriteDataByLocalIdentifierPosthandler

/*
___Service_22_application_interface_map(){ }
*/
#define kwp2k_core_Diag_read_data_msgid  			ApplDiagReadDataByCommonId

/* #define ApplDiagReadDataByCommonIdPosthandler */

/*
___Service_28_application_interface_map(){ }
*/

#define kwp2k_core_Diag_ControlCommunicationControl      ApplDiag_CommunicatinControl

/*
___Service_2E_application_interface_map(){ }
*/
#define kwp2k_core_Diag_write_data_msgid			ApplDiagWriteDataByCommonId

/* #define ApplDiagWriteDataByCommonIdPosthandler */

/*
___Service_2F_application_interface_map(){ }
*/
#define kwp2k_core_Diag_IOControlByDataIdentifier   ApplDiagInputOutputControlByLocalId

/*
___Service_30_application_interface_map(){ }
*/
/*#define kwp2k_core_Diag_IOControlByLocalDataIdentifier  ApplDiagInputOutputControlByLocalId*/

/*
___Service_31_application_interface_map(){ }
*/
#define kwp2k_core_Diag_Start_RoutineControl        ApplDiagStartRoutineByLocaldentifier

/*
___Service_32_application_interface_map(){ }
*/
#define kwp2k_core_Diag_Stop_RoutineControl			ApplDiagStopRoutineByLocalIdentifier	

/*
___Service_23_application_interface_map(){ }
*/
#define kwp2k_core_Diag_Read_Memory_by_Address 	ApplDiagReadDataByMemory
/*
___Service_3D_application_interface_map(){ }
*/
#define kwp2k_core_Diag_Write_Memory_by_Address  ApplDiagWriteDataByMemory

/*
___Service_85_application_interface_map(){ }
*/
#define kwp2k_core_Diag_ControlDTCSetting           ApplDiag_ControlDTCSetting

/*
___Service_27_application_interface_map(){ }
*/
#define kwp2k_core_Diag_SecurityAccess				ApplDiagSecurityAccess
/* Configure below function if security access status need to be reset */
#define kwp2k_core_reset_security_status			fdiag_reset_security


#ifdef ERROR_HANDLER_SUPPORTED
#define	kwp2k_diag_err_handler_cold_init				 	diag_errlog_cold_init							 
#define	kwp2k_diag_err_handler_warm_init				 	diag_errlog_warm_init							 
#define	kwp2k_diag_err_handler_dtc_manager				 	diag_errlog_dtc_manager						 
#define	kwp2k_diag_err_handler_erase_dtcs				 	diag_errlog_erase_dtcs						 
#define	kwp2k_diag_err_handler_is_dtc_matching_to_status	diag_errlog_is_dtc_matching_to_status			 
#define	kwp2k_diag_err_handler_get_nth_dtc_val				diag_errlog_get_nth_dtc_val					 
#define	kwp2k_diag_err_handler_get_index_by_dtc				diag_errlog_get_index_by_dtc					 
#define	kwp2k_diag_err_handler_find_nth_dtc_status			diag_errlog_find_nth_dtc_status				 
#define kwp2k_diag_errlog_count_dtc							diag_errlog_count_dtc
#endif /*ERROR_HANDLER_SUPPORTED*/


#endif
/* DIAG_KWP2K_DI_CORE_CFG */






